import type { Express } from "express";
import { createServer, type Server } from "http";
import fetch from "node-fetch";
import jwt from "jsonwebtoken";
import { storage } from "./storage";
import { generateRecipeWithGrok } from "./grok";
import { createInstacartRecipePage } from "./instacart";
import { getRecipeFromYouTube, findBestRecipeVideo } from "./videoRecipeExtractor";
import { extractFoodNameForNutrition, getServingSizeMultiplier } from "./nutritionParser";
import { parseIngredientsWithGPT } from "./gptIngredientParser";
import { authenticateToken } from "./auth"; // Import JWT auth middleware
import { rateLimiter } from "./rateLimiter";

import Stripe from "stripe";
import { insertProfileSchema, type InsertProfile } from "@shared/schema";

// YouTube API utilities
const YOUTUBE_API_KEY = process.env.YOUTUBE_API_KEY;
const YOUTUBE_API_BASE_URL = 'https://www.googleapis.com/youtube/v3';

// Stripe configuration
if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error('Missing required Stripe secret: STRIPE_SECRET_KEY');
}
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: "2025-06-30.basil",
});

export async function registerRoutes(app: Express): Promise<Server> {
  // Auth middleware - Replit Auth disabled
  // await setupAuth(app);

  // Auth routes (Replit auth - commented out to use standard auth)
  // app.get('/api/auth/user', authenticateToken, async (req: any, res) => {
  //   try {
  //     // First try to get user by the stored database ID
  //     let replitUser;
  //     if (req.user.dbUserId) {
  //       console.log('🔍 Looking for user with stored DB ID:', req.user.dbUserId);
  //       replitUser = await storage.getUser(req.user.dbUserId);
  //     }
  //     
  //     // If not found, try by Replit ID
  //     if (!replitUser) {
  //       const userId = req.user.claims.sub;
  //       console.log('🔍 Looking for user with Replit ID:', userId);
  //       replitUser = await storage.getUser(userId);
  //     }
  //     
  //     // If still not found, try by email as last resort
  //     if (!replitUser && req.user.claims.email) {
  //       console.log('🔍 Looking for user by email:', req.user.claims.email);
  //       // Create a new user with the correct mapping since email already exists
  //       const userData = {
  //         id: req.user.claims.sub,
  //         email: req.user.claims.email,
  //         firstName: req.user.claims.first_name,
  //         lastName: req.user.claims.last_name,
  //         profileImageUrl: req.user.claims.profile_image_url,
  //       };
  //       replitUser = await storage.upsertUser(userData);
  //       console.log('🔍 Created/updated user via email lookup:', replitUser.id);
  //     }
  //     
  //     console.log('🔍 Found user in DB:', replitUser ? 'YES' : 'NO');
  //     
  //     if (!replitUser) {
  //       console.log('❌ User not found in database');
  //       return res.status(404).json({ message: "User not found" });
  //     }
  //     
  //     // Transform Replit user data to match app's expected format
  //     const transformedUser = {
  //       id: replitUser.id,
  //       email: replitUser.email || '',
  //       phone: '', // Replit doesn't provide phone, use empty string
  //       full_name: [replitUser.firstName, replitUser.lastName].filter(Boolean).join(' ') || replitUser.email?.split('@')[0] || 'User',
  //       created_at: replitUser.createdAt || new Date().toISOString(),
  //       updated_at: replitUser.updatedAt || new Date().toISOString(),
  //       profileImageUrl: replitUser.profileImageUrl
  //     };
  //     
  //     res.json({ user: transformedUser });
  //   } catch (error) {
  //     console.error("Error fetching user:", error);
  //     res.status(500).json({ message: "Failed to fetch user" });
  //   }
  // });

  // Standard email/password auth routes
  const { registerUser, loginUser, getCurrentUser, authenticateToken } = await import("./auth");
  
  app.post("/api/auth/register", registerUser);
  app.post("/api/auth/login", loginUser);
  app.get("/api/auth/user", authenticateToken, getCurrentUser);

  // Google OAuth routes
  const { passport, isGoogleOAuthConfigured, handleGoogleCallback } = await import("./googleAuth");
  
  if (isGoogleOAuthConfigured) {
    // Initiate Google OAuth login
    app.get("/api/auth/google", (req, res, next) => {
      console.log("Google OAuth initiated");
      console.log("Client ID:", process.env.GOOGLE_CLIENT_ID);
      console.log("Callback URL:", `https://${process.env.REPLIT_DEV_DOMAIN}/api/auth/google/callback`);
      passport.authenticate("google", {
        scope: ["profile", "email"]
      })(req, res, next);
    });

    // Handle Google OAuth callback
    app.get("/api/auth/google/callback", 
      passport.authenticate("google", { session: false, failureRedirect: "/?error=google_auth_failed" }),
      async (req, res) => {
        try {
          const user = req.user as any;
          if (!user) {
            return res.redirect("/?error=no_user");
          }

          const { token, user: userWithoutPassword } = await handleGoogleCallback(user);
          
          // Redirect to frontend with token and user info
          const userData = encodeURIComponent(JSON.stringify(userWithoutPassword));
          res.redirect(`/?token=${token}&user=${userData}&success=google`);
        } catch (error) {
          console.error("Google callback error:", error);
          res.redirect("/?error=callback_failed");
        }
      }
    );

    console.log("Google OAuth routes registered successfully");
  } else {
    console.log("Google OAuth not configured - routes not registered");
  }

  // Test user routes
  app.post("/api/auth/test-login", async (req, res) => {
    try {
      // Login with test user credentials
      const testEmail = "test@example.com";
      const testPassword = "testuser123";

      const user = await storage.getUserByEmail(testEmail);
      if (!user) {
        // Create test user if it doesn't exist
        const { hashPassword } = await import("./auth");
        const hashedPassword = await hashPassword(testPassword);
        
        const newUser = await storage.createUser({
          email: testEmail,
          phone: "555-TEST-USER",
          password_hash: hashedPassword,
          full_name: "Test User"
        });

        const { generateToken } = await import("./auth");
        const token = generateToken(newUser.id.toString());

        const { password_hash, ...userWithoutPassword } = newUser;
        return res.json({
          user: userWithoutPassword,
          token,
          message: "Test user created and logged in successfully"
        });
      }

      // User exists, generate token
      const { generateToken } = await import("./auth");
      const token = generateToken(user.id.toString());

      const { password_hash, ...userWithoutPassword } = user;
      res.json({
        user: userWithoutPassword,
        token,
        message: "Test user login successful"
      });

    } catch (error: any) {
      console.error("Test login error:", error);
      res.status(500).json({ message: "Test login failed" });
    }
  });

  app.post("/api/auth/reset-test-user", async (req, res) => {
    try {
      const testEmail = "test@example.com";
      
      // Check if test user exists
      const existingUser = await storage.getUserByEmail(testEmail);
      if (!existingUser) {
        return res.status(404).json({ message: "Test user not found" });
      }

      // Reset password to default
      const { hashPassword } = await import("./auth");
      const defaultPassword = "testuser123";
      const hashedPassword = await hashPassword(defaultPassword);

      // Update user password in database
      await storage.updateUser(existingUser.id, {
        password_hash: hashedPassword
      });
      
      res.json({ 
        message: "Test user reset successfully. Password is now 'testuser123'",
        email: testEmail 
      });

    } catch (error: any) {
      console.error("Test user reset error:", error);
      res.status(500).json({ message: "Failed to reset test user" });
    }
  });

  // Stripe payment routes
  app.post("/api/create-payment-intent", async (req, res) => {
    try {
      const { amount, paymentType } = req.body;

      // Set amount based on payment type
      let paymentAmount;
      let description;

      if (paymentType === 'founders') {
        paymentAmount = 9900; // $99.00 in cents
        description = "Healthy Mama Founders Offer - Lifetime Access";
      } else if (paymentType === 'trial') {
        paymentAmount = 0; // $0 for trial setup
        description = "Healthy Mama 21-Day Premium Trial Setup";
      } else {
        paymentAmount = Math.round((amount || 0) * 100); // Convert to cents
        description = "Healthy Mama Payment";
      }

      const paymentIntent = await stripe.paymentIntents.create({
        amount: paymentAmount,
        currency: "usd",
        description: description,
        metadata: {
          paymentType: paymentType || 'general'
        }
      });

      res.json({ 
        clientSecret: paymentIntent.client_secret,
        amount: paymentAmount / 100 // Send back amount in dollars
      });
    } catch (error: any) {
      console.error('Error creating payment intent:', error);
      res.status(500).json({ 
        message: "Error creating payment intent: " + error.message 
      });
    }
  });

  // Create subscription for 21-day trial (sets up future billing)
  app.post('/api/create-trial-subscription', async (req, res) => {
    try {
      const { email, name } = req.body;

      if (!email) {
        return res.status(400).json({ message: 'Email is required' });
      }

      // Create customer
      const customer = await stripe.customers.create({
        email: email,
        name: name || '',
        metadata: {
          trialType: '21-day-premium'
        }
      });

      // Create setup intent for future payments (trial)
      const setupIntent = await stripe.setupIntents.create({
        customer: customer.id,
        payment_method_types: ['card'],
        usage: 'off_session',
        metadata: {
          type: '21-day-trial'
        }
      });

      res.json({
        customerId: customer.id,
        clientSecret: setupIntent.client_secret,
        message: 'Trial setup created successfully'
      });
    } catch (error: any) {
      console.error('Error creating trial subscription:', error);
      res.status(500).json({ 
        message: "Error setting up trial: " + error.message 
      });
    }
  });

  // Recipe generation API
  app.post("/api/recipes/generate", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User ID not found" });
      }

      const { 
        recipeType, 
        cuisine, 
        dietRestrictions, 
        cookingTime, 
        availableIngredients, 
        excludeIngredients, 
        description,
        difficulty,
        preferYouTube,
        generationMode,
        skipNutrition,
        skipVideoEnhancement
      } = req.body;

      if (!description) {
        return res.status(400).json({ message: "Recipe description is required" });
      }

      console.log(`Recipe generation request: ${description}`);
      console.log(`Generation mode: ${generationMode || 'legacy'}`);

      let recipe;

      if (generationMode === 'fast') {
        console.log("Fast mode: Finding YouTube video suggestion with Spoonacular time");

        try {
          // First get Spoonacular data for accurate cooking time
          let spoonacularTime = 30; // fallback

          if (process.env.SPOONACULAR_API_KEY) {
            try {
              const params = new URLSearchParams({
                apiKey: process.env.SPOONACULAR_API_KEY,
                query: description,
                number: '1',
                addRecipeInformation: 'true'
              });

              // Add filters to Spoonacular search
              if (cuisine && cuisine !== 'Any Cuisine') {
                params.append('cuisine', cuisine.toLowerCase());
              }
              if (dietRestrictions && dietRestrictions !== 'None') {
                params.append('diet', dietRestrictions.toLowerCase());
              }
              if (cookingTime && cookingTime !== 'Any Time') {
                const timeMap: Record<string, number> = {
                  'Under 15 min': 15,
                  'Under 30 min': 30,
                  'Under 1 hour': 60,
                  '1+ hours': 999
                };
                const maxTime = timeMap[cookingTime];
                if (maxTime) {
                  params.append('maxReadyTime', maxTime.toString());
                }
              }

              const spoonacularUrl = `https://api.spoonacular.com/recipes/complexSearch?${params.toString()}`;
              const response = await fetch(spoonacularUrl);
              const data = await response.json() as any;

              if (data.results && data.results.length > 0) {
                spoonacularTime = data.results[0].readyInMinutes || 30;
                console.log(`Using Spoonacular cooking time: ${spoonacularTime} minutes`);
              }
            } catch (spoonError) {
              console.log("Spoonacular lookup failed, using default time");
            }
          }

          // Fast mode: Just find a YouTube video without full recipe extraction
          const videoInfo = await findBestRecipeVideo(description, {
            cuisine,
            diet: dietRestrictions,
            cookingTime,
            availableIngredients,
            excludeIngredients
          }, spoonacularTime);

          if (videoInfo) {
            // Create a minimal recipe object with just video info and Spoonacular time
            recipe = {
              title: videoInfo.title,
              description: `Watch this video: "${videoInfo.title}" by ${videoInfo.channelTitle}`,
              image_url: videoInfo.thumbnailUrl,
              time_minutes: spoonacularTime, // Use Spoonacular time instead of default
              cuisine: cuisine || 'Any Cuisine',
              diet: dietRestrictions || 'None',
              ingredients: [`Watch the video for ingredients`],
              instructions: [`Follow along with the video: ${videoInfo.title}`],
              source_url: `https://www.youtube.com/watch?v=${videoInfo.id}`,
              source_name: videoInfo.channelTitle,
              video_id: videoInfo.id,
              video_title: videoInfo.title,
              video_channel: videoInfo.channelTitle,
              total_nutrition: {
                calories: 0,
                protein: 0,
                carbs: 0,
                fat: 0,
                fiber: 0,
                sugar: 0,
                sodium: 0
              }
            };
          } else {
            return res.status(404).json({ message: "No suitable video found for your query" });
          }
        } catch (error) {
          console.error("Fast mode video search failed:", error);
          return res.status(500).json({ message: "Failed to find video suggestion" });
        }
      } else {
        // Detailed mode: Full recipe generation with YouTube extraction
        console.log("Detailed mode: Generating complete recipe");

        try {
          // Get a complete recipe from YouTube video with enhanced filter-aware search
          const youtubeRecipe = await getRecipeFromYouTube(description, {
            cuisine,
            diet: dietRestrictions,
            cookingTime,
            availableIngredients,
            excludeIngredients
          });

          if (youtubeRecipe) {
            console.log("Successfully extracted recipe data from YouTube");
            console.log(`Recipe has ${youtubeRecipe.ingredients.length} ingredients and ${youtubeRecipe.instructions.length} instructions`);

            // Add any additional user preferences and ensure image URL is set
            youtubeRecipe.cuisine = cuisine || youtubeRecipe.cuisine;
            youtubeRecipe.diet = dietRestrictions || youtubeRecipe.diet;
            youtubeRecipe.image_url = youtubeRecipe.thumbnailUrl || youtubeRecipe.image_url;

            recipe = youtubeRecipe;
          } else {
            console.log("No suitable YouTube recipe found, falling back to Grok");
            // Fall back to Grok if YouTube extraction fails
            recipe = await generateRecipeWithGrok({
              recipeType,
              cuisine,
              dietRestrictions,
              cookingTime,
              availableIngredients,
              excludeIngredients,
              description
            });
          }
        } catch (youtubeError) {
          console.error("YouTube recipe extraction failed, falling back to Grok:", youtubeError);
          // Fall back to Grok if YouTube search fails
          recipe = await generateRecipeWithGrok({
            recipeType,
            cuisine,
            dietRestrictions,
            cookingTime,
            availableIngredients,
            excludeIngredients,
            description
          });
        }
      }

      // Save and return the recipe (for both fast and detailed modes)
      if (recipe) {
        // Add nutrition calculation for detailed recipes
        if (generationMode === 'detailed' && recipe.ingredients && recipe.ingredients.length > 0) {
          try {
            const { calculateRecipeNutrition } = await import('./nutritionCalculator');

            // Helper function to get USDA nutrition data
            const getUSDANutrition = async (foodName: string) => {
              try {
                console.log(`Looking up USDA nutrition for: "${foodName}"`);
                const searchResponse = await fetch(`https://api.nal.usda.gov/fdc/v1/foods/search?query=${encodeURIComponent(foodName)}&api_key=${process.env.USDA_API_KEY}&pageSize=1`);

                if (searchResponse.ok) {
                  const searchData: any = await searchResponse.json();
                  if (searchData.foods && searchData.foods.length > 0) {
                    const foodId = searchData.foods[0].fdcId;
                    console.log(`Found USDA food ID ${foodId} for "${foodName}"`);
                    const nutritionResponse = await fetch(`https://api.nal.usda.gov/fdc/v1/food/${foodId}?api_key=${process.env.USDA_API_KEY}`);

                    if (nutritionResponse.ok) {
                      const nutritionData: any = await nutritionResponse.json();
                      const nutrients = nutritionData.foodNutrients || [];

                      let nutrition = { calories: 0, protein: 0, carbs: 0, fat: 0, fiber: 0, sugar: 0, sodium: 0 };

                      nutrients.forEach((nutrient: any) => {
                        const name = nutrient.nutrient?.name?.toLowerCase() || '';
                        const value = parseFloat(nutrient.amount) || 0;

                        if (name.includes('energy')) nutrition.calories = value;
                        else if (name.includes('protein')) nutrition.protein = value;
                        else if (name.includes('carbohydrate')) nutrition.carbs = value;
                        else if (name.includes('total lipid') || name.includes('fat')) nutrition.fat = value;
                        else if (name.includes('fiber')) nutrition.fiber = value;
                        else if (name.includes('sugars')) nutrition.sugar = value;
                        else if (name.includes('sodium')) nutrition.sodium = value;
                      });

                      console.log(`USDA nutrition for "${foodName}": ${nutrition.calories}cal, ${nutrition.protein}g protein`);
                      return nutrition;
                    } else {
                      console.log(`Failed to get nutrition data for food ID ${foodId}`);
                    }
                  } else {
                    console.log(`No USDA foods found for "${foodName}"`);
                  }
                } else {
                  console.log(`USDA search failed for "${foodName}": ${searchResponse.status}`);
                }
                return null;
              } catch (error) {
                console.error(`Error fetching USDA nutrition for ${foodName}:`, error);
                return null;
              }
            };

            // Calculate nutrition with proper serving breakdown
            const nutritionData = await calculateRecipeNutrition(recipe, getUSDANutrition);

            recipe.nutrition_info = {
              calories: nutritionData.perServing.calories,
              protein_g: nutritionData.perServing.protein,
              carbs_g: nutritionData.perServing.carbs,
              fat_g: nutritionData.perServing.fat,
              fiber_g: nutritionData.perServing.fiber,
              sugar_g: nutritionData.perServing.sugar,
              sodium_mg: nutritionData.perServing.sodium,
              servings: nutritionData.servings,
              total_calories: nutritionData.calories
            };

            console.log(`Added per-serving nutrition: ${nutritionData.perServing.calories}cal per serving (${nutritionData.servings} servings total, ${nutritionData.calories} total calories)`);
          } catch (nutritionError: any) {
            console.log('Nutrition calculation failed:', nutritionError.message);
            console.log('Proceeding without nutrition data');
          }
        }

        // Debug: Check video data before saving
        console.log("Recipe video data before saving:", {
          video_id: recipe.video_id,
          video_title: recipe.video_title,
          video_channel: recipe.video_channel
        });

        // Ensure all required fields are included when saving
        const recipeToSave = {
          ...recipe,
          video_id: recipe.video_id || null,
          video_title: recipe.video_title || null,
          video_channel: recipe.video_channel || null,
          time_minutes: recipe.time_minutes || recipe.timeMinutes || 30, // Default to 30 min if not set
          image_url: recipe.image_url || recipe.imageUrl || `https://source.unsplash.com/800x600/?food,${encodeURIComponent(recipe.title.toLowerCase())},cooking,delicious`
        };

        // DISH NAME MAPPING: Map to familiar, recognizable names
        let familiarTitle = recipeToSave.title;
        try {
          const { mapToFamiliarDishName } = await import('./familiarDishNameMapper');
          const mapping = mapToFamiliarDishName(
            recipeToSave.title,
            'unknown', // default cuisine type if not available
            recipeToSave.ingredients
          );

          if (mapping.confidence > 0.6) {
            console.log(`📝 Dish name mapping: "${recipeToSave.title}" → "${mapping.familiarName}" (${mapping.cuisine}, confidence: ${mapping.confidence})`);
            familiarTitle = mapping.familiarName;
          }
        } catch (mappingError) {
          console.warn('Dish name mapping error:', mappingError);
          // Continue with original title
        }

        // DIETARY VALIDATION: Check recipe compliance before saving
        let finalRecipe = { ...recipeToSave, title: familiarTitle, user_id: userId };
        if (dietRestrictions) {
          try {
            const { validateRecipeDietaryCompliance, getSuggestedRecipeFixes } = await import('./dietaryValidationService');

            const validation = await validateRecipeDietaryCompliance(recipeToSave, [dietRestrictions]);
            console.log(`🔍 Dietary validation: ${validation.isCompliant ? 'PASS' : 'FAIL'} (${validation.violations.length} violations)`);

            if (!validation.isCompliant) {
              console.warn(`❌ Dietary violations detected for "${dietRestrictions}":`, validation.violations.map(v => v.ingredient));

              // Try to automatically fix the recipe
              const fixedRecipe = await getSuggestedRecipeFixes(recipeToSave, validation, [dietRestrictions]);

              // Re-validate the fixed recipe
              const revalidation = await validateRecipeDietaryCompliance(fixedRecipe, [dietRestrictions]);

              if (revalidation.isCompliant) {
                console.log(`✅ Recipe automatically fixed for dietary compliance`);
                finalRecipe = fixedRecipe;
              } else {
                console.warn(`⚠️ Could not fully fix recipe, serving with warnings`);
                // Add validation warnings to recipe metadata
                finalRecipe.dietary_warnings = validation.suggestions;
                finalRecipe.dietary_compliance_score = validation.confidence;
              }
            } else {
              console.log(`✅ Recipe passes dietary validation for "${dietRestrictions}"`);
            }
          } catch (validationError) {
            console.error('Dietary validation error:', validationError);
            // Continue without validation rather than failing
          }
        }

        const savedRecipe = await storage.createRecipe(finalRecipe);
        console.log("Returning recipe with video data:", {
          id: savedRecipe.id,
          title: savedRecipe.title,
          video_id: savedRecipe.video_id,
          video_title: savedRecipe.video_title,
          video_channel: savedRecipe.video_channel,
          dietary_validated: !!dietRestrictions
        });
        return res.json(savedRecipe);
      } else {
        return res.status(500).json({ message: "Failed to generate recipe" });
      }
    } catch (error) {
      console.error("Error generating recipe:", error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return res.status(500).json({ message: `Failed to generate recipe: ${errorMessage}` });
    }
  });

  // Get popular recipes
  app.get("/api/recipes/popular", async (_req, res) => {
    try {
      const recipes = await storage.getPopularRecipes();
      res.json(recipes);
    } catch (error) {
      console.error("Error fetching popular recipes:", error);
      res.status(500).json({ message: "Failed to fetch popular recipes" });
    }
  });

  // Get saved recipes
  app.get("/api/recipes/saved", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User ID not found" });
      }
      const recipes = await storage.getSavedRecipes(userId);
      res.json(recipes);
    } catch (error) {
      console.error("Error fetching saved recipes:", error);
      res.status(500).json({ message: "Failed to fetch saved recipes" });
    }
  });

  // Get generated recipes
  app.get("/api/recipes/generated", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User ID not found" });
      }
      const recipes = await storage.getGeneratedRecipes(userId);
      res.json(recipes);
    } catch (error) {
      console.error("Error fetching generated recipes:", error);
      res.status(500).json({ message: "Failed to fetch generated recipes" });
    }
  });

  // Save a recipe
  app.post("/api/recipes/:id/save", authenticateToken, async (req: any, res) => {
    try {
      const recipeId = parseInt(req.params.id);

      if (isNaN(recipeId)) {
        console.log(`Invalid recipe ID: ${req.params.id}`);
        return res.status(400).json({ message: "Invalid recipe ID" });
      }

      console.log(`Attempting to save recipe ${recipeId}`);

      // Check if recipe exists first
      const recipe = await storage.getRecipeById(recipeId);
      if (!recipe) {
        console.log(`Recipe ${recipeId} not found in database`);
        return res.status(404).json({ message: "Recipe not found" });
      }

      const savedRecipe = await storage.saveRecipe(recipeId);

      if (savedRecipe) {
        console.log(`Recipe ${recipeId} saved successfully:`, savedRecipe);
        res.json({ 
          message: "Recipe saved successfully",
          recipe: savedRecipe,
          success: true 
        });
      } else {
        console.log(`Failed to save recipe ${recipeId} - storage returned null`);
        res.status(500).json({ message: "Failed to save recipe - storage error" });
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      const errorStack = error instanceof Error ? error.stack : undefined;
      console.error("Error saving recipe:", {
        recipeId: req.params.id,
        error: errorMessage,
        stack: errorStack
      });
      res.status(500).json({ 
        message: "Failed to save recipe", 
        error: errorMessage,
        success: false
      });
    }
  });

  // Unsave a recipe
  app.delete("/api/recipes/:id/save", authenticateToken, async (req: any, res) => {
    try {
      const recipeId = parseInt(req.params.id);

      if (isNaN(recipeId)) {
        console.log(`Invalid recipe ID for unsave: ${req.params.id}`);
        return res.status(400).json({ message: "Invalid recipe ID" });
      }

      console.log(`Attempting to unsave recipe ${recipeId}`);

      const result = await storage.unsaveRecipe(recipeId);

      console.log(`Recipe ${recipeId} unsaved successfully, result:`, result);
      res.json({ 
        message: "Recipe unsaved successfully",
        success: true
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      const errorStack = error instanceof Error ? error.stack : undefined;
      console.error("Error unsaving recipe:", {
        recipeId: req.params.id,
        error: errorMessage,
        stack: errorStack
      });
      res.status(500).json({ 
        message: "Failed to unsave recipe", 
        error: errorMessage,
        success: false
      });
    }
  });

  // Create shoppable recipe with Instacart
  app.post("/api/recipes/instacart", async (req, res) => {
    try {
      const recipe = req.body;

      if (!recipe || !recipe.title) {
        return res.status(400).json({ message: "Recipe data is required" });
      }

      const shoppableRecipe = await createInstacartRecipePage(recipe);
      res.json(shoppableRecipe);
    } catch (error) {
      console.error("Error creating shoppable recipe:", error);
      res.status(500).json({ message: "Failed to create shoppable recipe" });
    }
  });

  // Create Instacart shopping list (for Search page)
  app.post("/api/instacart/create-list", async (req, res) => {
    try {
      const { ingredients, recipeName } = req.body;

      if (!ingredients || !Array.isArray(ingredients) || !recipeName) {
        return res.status(400).json({ message: "Recipe ingredients and name are required" });
      }

      // Format ingredients for Instacart API
      const formattedIngredients = ingredients.map((ingredient: string, index: number) => ({
        name: ingredient,
        display_text: ingredient,
        measurements: [{
          quantity: 1,
          unit: "item"
        }]
      }));

      const recipeData = {
        title: recipeName,
        image_url: "", // Optional - can be empty
        link_type: "recipe",
        instructions: ["Follow the recipe instructions"],
        ingredients: formattedIngredients,
        landing_page_configuration: {
          partner_linkback_url: process.env.REPLIT_DOMAINS ? 
            `https://${process.env.REPLIT_DOMAINS.split(',')[0]}` : 
            "https://example.com",
          enable_pantry_items: true
        }
      };

      const shoppableRecipe: any = await createInstacartRecipePage(recipeData);

      // Return the shopping URL that the frontend expects
      res.json({ 
        shopping_url: shoppableRecipe?.products_link_url || shoppableRecipe?.link_url || shoppableRecipe?.url,
        ...shoppableRecipe 
      });
    } catch (error) {
      console.error("Error creating Instacart shopping list:", error);
      res.status(500).json({ message: "Failed to create shopping list" });
    }
  });
  
  // Create shopping list from meal plan (for Grocery List Panel)
  app.post("/api/create-shopping-list", authenticateToken, async (req: any, res) => {
    console.log("🛒 Create shopping list endpoint hit");
    console.log("Request body:", req.body);
    console.log("User:", req.user);
    
    try {
      const { mealPlanId } = req.body;
      const userId = req.user?.id;
      
      if (!userId) {
        console.log("❌ No user ID found");
        return res.status(401).json({ message: "User not authenticated" });
      }
      
      if (!mealPlanId) {
        console.log("❌ No meal plan ID provided");
        return res.status(400).json({ message: "Meal plan ID is required" });
      }
      
      // Check if we have cached grocery list
      console.log("📦 Checking for cached grocery list:", mealPlanId);
      const cachedGroceryList = await storage.getGroceryListCache(mealPlanId, userId);
      
      if (cachedGroceryList) {
        console.log("✅ Using cached grocery list from database");
        console.log("   Cache created at:", cachedGroceryList.created_at);
        console.log("   Has Instacart URL:", !!cachedGroceryList.shopping_url);
        
        // If we have a cached Instacart URL, return it immediately
        if (cachedGroceryList.shopping_url) {
          return res.json({
            shoppingUrl: cachedGroceryList.shopping_url,
            consolidatedIngredients: cachedGroceryList.consolidated_ingredients,
            savings: cachedGroceryList.savings,
            recommendations: cachedGroceryList.recommendations,
            fromCache: true
          });
        }
        
        // We have cached ingredients but no Instacart URL yet
        // Generate the Instacart URL and update cache
        try {
          const { createInstacartRecipePage } = await import("./instacart");
          
          const recipeData = {
            title: `Meal Plan Shopping List`,
            description: `Shopping list for your meal plan`,
            ingredients: cachedGroceryList.consolidated_ingredients
          };
          
          const shoppableRecipe: any = await createInstacartRecipePage(recipeData);
          const shoppingUrl = shoppableRecipe?.products_link_url || shoppableRecipe?.link_url || shoppableRecipe?.url;
          
          // Update cache with the Instacart URL
          if (shoppingUrl) {
            await storage.saveGroceryListCache({
              meal_plan_id: mealPlanId,
              user_id: userId,
              consolidated_ingredients: cachedGroceryList.consolidated_ingredients,
              shopping_url: shoppingUrl,
              savings: cachedGroceryList.savings,
              recommendations: cachedGroceryList.recommendations,
              expires_at: cachedGroceryList.expires_at
            });
          }
          
          return res.json({
            shoppingUrl,
            consolidatedIngredients: cachedGroceryList.consolidated_ingredients,
            savings: cachedGroceryList.savings,
            recommendations: cachedGroceryList.recommendations,
            fromCache: true,
            ...shoppableRecipe
          });
        } catch (instacartError) {
          console.error("⚠️ Failed to generate Instacart URL, returning cached data:", instacartError);
          // Return cached data without Instacart URL
          return res.json({
            consolidatedIngredients: cachedGroceryList.consolidated_ingredients,
            savings: cachedGroceryList.savings,
            recommendations: cachedGroceryList.recommendations,
            fromCache: true
          });
        }
      }
      
      // No cache, proceed with normal flow
      console.log("📋 No cache found, fetching meal plan:", mealPlanId, "for user:", userId);
      const mealPlan = await storage.getMealPlan(mealPlanId, userId);
      if (!mealPlan) {
        console.log("❌ Meal plan not found");
        return res.status(404).json({ message: "Meal plan not found" });
      }
      console.log("✅ Meal plan found:", mealPlan.name);
      
      // Extract all ingredients from the meal plan
      const allIngredients: string[] = [];
      Object.entries(mealPlan.mealPlan).forEach(([day, dayMeals]: [string, any]) => {
        Object.entries(dayMeals).forEach(([mealType, meal]: [string, any]) => {
          if (meal && meal.ingredients) {
            allIngredients.push(...meal.ingredients);
          }
        });
      });
      
      // Intelligently consolidate ingredients using AI
      console.log("🤖 Consolidating ingredients with AI...");
      const { consolidateIngredientsWithAI, formatForInstacart } = await import("./intelligentGroceryListOptimizer");
      const consolidationResult = await consolidateIngredientsWithAI(allIngredients);
      
      console.log(`✅ Consolidated ${allIngredients.length} ingredients into ${consolidationResult.consolidatedIngredients.length} items`);
      console.log(`💰 Removed ${consolidationResult.savings.duplicatesRemoved} duplicates`);
      
      // Format ingredients for Instacart API
      const formattedIngredients = formatForInstacart(consolidationResult.consolidatedIngredients);
      
      const recipeData = {
        title: `Grocery List for ${mealPlan.name}`,
        image_url: "",
        link_type: "recipe",
        instructions: ["Shop for ingredients"],
        ingredients: formattedIngredients,
        landing_page_configuration: {
          partner_linkback_url: process.env.REPLIT_DOMAINS ? 
            `https://${process.env.REPLIT_DOMAINS.split(',')[0]}` : 
            "https://example.com",
          enable_pantry_items: true
        }
      };
      
      // Check if Instacart API key is available
      console.log("🔑 Instacart API key status:", process.env.INSTACART_API_KEY ? "Available" : "Not found");
      if (!process.env.INSTACART_API_KEY) {
        throw new Error("Instacart API key is required. Set the INSTACART_API_KEY environment variable.");
      }
      
      const { createInstacartRecipePage } = await import("./instacart");
      const shoppableRecipe: any = await createInstacartRecipePage(recipeData);
      const shoppingUrl = shoppableRecipe?.products_link_url || shoppableRecipe?.link_url || shoppableRecipe?.url;
      
      // Save to cache for future use
      try {
        await storage.saveGroceryListCache({
          meal_plan_id: mealPlanId,
          user_id: userId,
          consolidated_ingredients: consolidationResult.consolidatedIngredients,
          shopping_url: shoppingUrl,
          savings: consolidationResult.savings,
          recommendations: consolidationResult.recommendations,
          expires_at: null // Will default to 7 days
        });
        console.log('✅ Grocery list cached for meal plan:', mealPlanId);
      } catch (cacheError) {
        console.error('⚠️ Failed to cache grocery list (non-critical):', cacheError);
      }
      
      // Return the shopping URL with consolidation info
      res.json({ 
        shoppingUrl,
        consolidatedIngredients: consolidationResult.consolidatedIngredients,
        savings: consolidationResult.savings,
        recommendations: consolidationResult.recommendations,
        ...shoppableRecipe 
      });
    } catch (error) {
      console.error("Error creating shopping list:", error);
      res.status(500).json({ message: "Failed to create shopping list" });
    }
  });

  // Meal plan CRUD operations
  app.get("/api/meal-plans/saved", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const savedPlans = await storage.getSavedMealPlans(userId);
      console.log('Raw meal plans from DB:', JSON.stringify(savedPlans.slice(0, 1), null, 2));

      // CRITICAL FIX: Map database field (mealPlan) to frontend field (meal_plan)
      const formattedPlans = savedPlans.map(plan => {
        const { mealPlan, ...planWithoutMealPlan } = plan;
        return {
          ...planWithoutMealPlan,
          meal_plan: mealPlan // Map camelCase DB field to snake_case frontend field
        };
      });

      console.log('Formatted meal plans for frontend:', JSON.stringify(formattedPlans.slice(0, 1), null, 2));
      res.json(formattedPlans);
    } catch (error) {
      console.error("Error fetching saved meal plans:", error);
      res.status(500).json({ message: "Failed to fetch meal plans" });
    }
  });

  app.post("/api/meal-plans", authenticateToken, async (req: any, res) => {
    try {
      console.log('🔍 MEAL PLAN SAVE DEBUG:');
      console.log('   - Request headers:', req.headers.authorization ? 'Authorization Present' : 'No Auth Header');
      console.log('   - User from token:', req.user?.id || 'No user ID');
      console.log('   - Request body keys:', Object.keys(req.body));
      
      const userId = req.user?.id;
      if (!userId) {
        console.log('❌ SAVE FAILED: User not authenticated');
        return res.status(401).json({ message: "User not authenticated" });
      }

      const { name, description, meal_plan, is_auto_saved } = req.body;
      console.log('   - Plan name:', name);
      console.log('   - Meal plan exists:', !!meal_plan);
      console.log('   - Meal plan days:', meal_plan ? Object.keys(meal_plan) : 'none');

      if (!name || !meal_plan) {
        console.log('❌ SAVE FAILED: Missing required fields');
        return res.status(400).json({ message: "Name and meal plan are required" });
      }

      // Enhanced validation for meal plan structure
      if (typeof meal_plan !== 'object' || meal_plan === null) {
        console.log('❌ SAVE FAILED: meal_plan is not an object');
        return res.status(400).json({ message: "Invalid meal plan structure" });
      }

      const dayKeys = Object.keys(meal_plan);
      if (dayKeys.length === 0) {
        console.log('❌ SAVE FAILED: meal_plan has no days');
        return res.status(400).json({ message: "Meal plan must contain at least one day" });
      }

      // Validate each day has at least one meal
      for (const dayKey of dayKeys) {
        const dayMeals = meal_plan[dayKey];
        if (!dayMeals || typeof dayMeals !== 'object' || Object.keys(dayMeals).length === 0) {
          console.log(`❌ SAVE FAILED: ${dayKey} has no meals`);
          return res.status(400).json({ message: `Day ${dayKey} must contain at least one meal` });
        }
      }

      console.log('💾 Calling storage.saveMealPlan...');
      const savedPlan = await storage.saveMealPlan({
        userId: userId,
        name,
        description: description || "",
        mealPlan: meal_plan,
        isAutoSaved: is_auto_saved || false
      });

      console.log('✅ SAVE SUCCESS:', savedPlan?.id || 'unknown ID');
      
      // Auto-generate and cache the grocery list for this meal plan
      try {
        console.log('🛒 Auto-generating grocery list for saved meal plan:', savedPlan.id);
        
        // Import the consolidation function
        const { consolidateIngredients } = await import("./intelligentGroceryListOptimizer");
        
        // Consolidate the ingredients
        const consolidationResult = await consolidateIngredients(meal_plan);
        
        // Save to cache (without Instacart URL for now)
        await storage.saveGroceryListCache({
          meal_plan_id: savedPlan.id,
          user_id: userId,
          consolidated_ingredients: consolidationResult.consolidatedIngredients,
          shopping_url: null,
          savings: consolidationResult.savings,
          recommendations: consolidationResult.recommendations,
          expires_at: null // Will default to 7 days
        });
        
        console.log('✅ Grocery list cached for meal plan:', savedPlan.id);
      } catch (cacheError) {
        console.error('⚠️ Failed to cache grocery list (non-critical):', cacheError);
        // Don't fail the save operation if caching fails
      }
      
      // Check if this is the user's first meal plan for achievement tracking
      const allUserPlans = await storage.getSavedMealPlans(userId);
      const isFirstMealPlan = allUserPlans.length === 1; // Just saved their first one
      
      // Return achievement data for frontend to trigger notifications
      res.json({
        ...savedPlan,
        achievements: {
          firstMealPlan: isFirstMealPlan
        }
      });
    } catch (error) {
      console.error("❌ SAVE ERROR:", error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      res.status(500).json({ message: "Failed to save meal plan", error: errorMessage });
    }
  });

  app.put("/api/meal-plans/:id", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      const planId = Number(req.params.id);
      const { name, description, meal_plan } = req.body;

      console.log('Update request - planId:', planId, 'name:', name, 'meal_plan exists:', !!meal_plan, 'meal_plan type:', typeof meal_plan);

      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      if (!name || !meal_plan) {
        return res.status(400).json({ message: "Name and meal plan are required" });
      }

      const updatedPlan = await storage.updateMealPlan(planId, userId, {
        name,
        description: description || "",
        mealPlan: meal_plan
      });

      if (!updatedPlan) {
        return res.status(404).json({ message: "Meal plan not found or unauthorized" });
      }

      console.log('Meal plan updated successfully:', updatedPlan.id);

      // Ensure we return valid JSON
      if (!updatedPlan) {
        return res.status(500).json({ message: "Update failed - no data returned" });
      }

      res.json(updatedPlan);
    } catch (error) {
      console.error("Error updating meal plan:", error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      res.status(500).json({ message: "Failed to update meal plan", error: errorMessage });
    }
  });

  app.delete("/api/meal-plans/:id", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      const planId = Number(req.params.id);

      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const deleted = await storage.deleteMealPlan(planId, userId);

      if (!deleted) {
        return res.status(404).json({ message: "Meal plan not found or unauthorized" });
      }

      console.log('Meal plan deleted successfully:', planId);
      res.json({ message: "Meal plan deleted successfully", success: true });
    } catch (error) {
      console.error("Error deleting meal plan:", error);
      res.status(500).json({ message: "Failed to delete meal plan" });
    }
  });

  // Meal completion routes
  app.get("/api/meal-plans/:id/completions", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      const mealPlanId = Number(req.params.id);

      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const completions = await storage.getMealCompletions(userId, mealPlanId);
      res.json(completions);
    } catch (error) {
      console.error("Error fetching meal completions:", error);
      res.status(500).json({ message: "Failed to fetch meal completions" });
    }
  });

  app.post("/api/meal-plans/:id/completions/toggle", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      const mealPlanId = Number(req.params.id);
      const { dayKey, mealType } = req.body;

      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      if (!dayKey || !mealType) {
        return res.status(400).json({ message: "dayKey and mealType are required" });
      }

      const completion = await storage.toggleMealCompletion(userId, mealPlanId, dayKey, mealType);
      res.json(completion);
    } catch (error) {
      console.error("Error toggling meal completion:", error);
      res.status(500).json({ message: "Failed to toggle meal completion" });
    }
  });

  // Complete entire meal plan
  app.post("/api/meal-plans/:id/complete", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      const mealPlanId = Number(req.params.id);

      console.log(`🚀 ROUTE DEBUG: Complete plan request - userId: ${userId}, mealPlanId: ${mealPlanId}`);

      if (!userId) {
        console.log(`❌ ROUTE DEBUG: User not authenticated`);
        return res.status(401).json({ message: "User not authenticated" });
      }

      console.log(`✅ ROUTE DEBUG: User authenticated, calling storage.completeMealPlan`);

      // Mark the meal plan as completed by setting a completion flag
      const completedPlan = await storage.completeMealPlan(userId, mealPlanId);
      
      console.log(`📊 ROUTE DEBUG: Storage returned:`, completedPlan ? 'Plan object' : 'null');

      if (!completedPlan) {
        console.log(`❌ ROUTE DEBUG: No plan returned from storage, sending 404`);
        return res.status(404).json({ message: "Meal plan not found or unauthorized" });
      }

      console.log(`✅ ROUTE DEBUG: Plan completed successfully, sending response`);
      res.json({ message: "Meal plan completed successfully", plan: completedPlan });
    } catch (error) {
      console.error("❌ ROUTE DEBUG: Error completing meal plan:", error);
      res.status(500).json({ message: "Failed to complete meal plan" });
    }
  });

  app.get("/api/meal-plan/latest", async (req, res) => {
    try {
      // Disabled caching - return empty response for now
      return res.status(404).json({ message: "No recent meal plan found" });
    } catch (error) {
      console.error("Error fetching latest meal plan:", error);
      res.status(500).json({ message: "Failed to fetch latest meal plan" });
    }
  });

  // ============= FOOD TRACKING / CALORIE TRACKER ENDPOINTS =============
  
  // Create a new food log entry
  app.post("/api/food-logs", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const { foods, imageUrl, mealType } = req.body;
      
      if (!foods || !Array.isArray(foods)) {
        return res.status(400).json({ message: "Foods array is required" });
      }

      // Calculate totals from included foods
      const totals = foods
        .filter((f: any) => f.included)
        .reduce((acc: any, f: any) => ({
          calories: acc.calories + (f.calories || 0),
          protein: acc.protein + (f.protein || 0),
          carbs: acc.carbs + (f.carbs || 0),
          fat: acc.fat + (f.fat || 0)
        }), { calories: 0, protein: 0, carbs: 0, fat: 0 });

      // Save to database
      const foodLog = await storage.createFoodLog({
        user_id: userId,
        image_url: imageUrl,
        foods: foods,
        total_calories: totals.calories,
        total_protein: totals.protein,
        total_carbs: totals.carbs,
        total_fat: totals.fat,
        meal_type: mealType,
        logged_at: new Date()
      });

      res.json(foodLog);
    } catch (error) {
      console.error("Error creating food log:", error);
      res.status(500).json({ message: "Failed to create food log" });
    }
  });

  // Get today's food logs
  app.get("/api/food-logs/today", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const logs = await storage.getFoodLogs(userId);
      
      // Calculate today's totals
      const totals = logs.reduce((acc, log) => ({
        totalCalories: acc.totalCalories + (log.total_calories || 0),
        totalProtein: acc.totalProtein + (log.total_protein || 0),
        totalCarbs: acc.totalCarbs + (log.total_carbs || 0),
        totalFat: acc.totalFat + (log.total_fat || 0)
      }), { totalCalories: 0, totalProtein: 0, totalCarbs: 0, totalFat: 0 });

      res.json({
        logs,
        ...totals
      });
    } catch (error) {
      console.error("Error fetching today's food logs:", error);
      res.status(500).json({ message: "Failed to fetch food logs" });
    }
  });

  // Get food logs for the last week
  app.get("/api/food-logs/week", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - 7);

      const logs = await storage.getFoodLogsByDateRange(userId, startDate, endDate);
      
      res.json(logs);
    } catch (error) {
      console.error("Error fetching week's food logs:", error);
      res.status(500).json({ message: "Failed to fetch food logs" });
    }
  });

  // Delete a food log
  app.delete("/api/food-logs/:id", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      const logId = parseInt(req.params.id);
      
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const success = await storage.deleteFoodLog(logId, userId);
      
      if (success) {
        res.json({ message: "Food log deleted successfully" });
      } else {
        res.status(404).json({ message: "Food log not found" });
      }
    } catch (error) {
      console.error("Error deleting food log:", error);
      res.status(500).json({ message: "Failed to delete food log" });
    }
  });

  // LogMeal API endpoint for food detection
  app.post("/api/detect-foods-logmeal", async (req, res) => {
    try {
      console.log('🍔 === LOGMEAL API ENDPOINT CALLED ===');
      const { image } = req.body;
      
      if (!image) {
        console.error('❌ No image data provided');
        return res.status(400).json({ error: "Image data is required" });
      }
      
      console.log('📊 Received image data:', {
        length: image.length,
        isBase64: image.includes('base64'),
        prefix: image.substring(0, 50)
      });
      
      // LogMeal API configuration
      const LOGMEAL_API_KEY = '79cbe9badc6d24d77ffbcd536692c6fd697de89d';
      const LOGMEAL_API_URL = 'https://api.logmeal.es/v2';
      
      console.log('🔑 Using LogMeal API');
      
      // Remove data URL prefix and convert to buffer
      const base64Image = image.replace(/^data:image\/\w+;base64,/, '');
      const imageBuffer = Buffer.from(base64Image, 'base64');
      console.log('📦 Image buffer size:', imageBuffer.length);
      
      // Use axios for proper form-data handling
      const axios = require('axios');
      const FormData = require('form-data');
      
      // Create form data for LogMeal API
      const formData = new FormData();
      formData.append('image', imageBuffer, {
        filename: 'image.jpg',
        contentType: 'image/jpeg'
      });
      
      console.log('📡 Calling LogMeal API for dish recognition...');
      console.log('🔗 Endpoint: /recognition/dish');
      console.log('📦 Form data buffer size:', imageBuffer.length);
      console.log('🔑 API Key (first 10 chars):', LOGMEAL_API_KEY.substring(0, 10) + '...');
      
      // Call LogMeal API - dish recognition endpoint for better results
      let logmealResponse;
      let logmealData;
      let endpoint = '/recognition/dish';
      
      try {
        // Try dish recognition first (better for complex meals)
        console.log('🚀 Attempting dish recognition endpoint...');
        
        try {
          logmealResponse = await axios.post(
            `${LOGMEAL_API_URL}${endpoint}`,
            formData,
            {
              headers: {
                'Authorization': `Bearer ${LOGMEAL_API_KEY}`,
                ...formData.getHeaders()
              },
              maxContentLength: Infinity,
              maxBodyLength: Infinity
            }
          );
          
          logmealData = logmealResponse.data;
          console.log('✅ Dish recognition successful');
          
        } catch (dishError: any) {
          console.log('⚠️ Dish endpoint failed:', dishError.response?.status || dishError.message);
          console.log('⚠️ Trying type recognition endpoint...');
          
          // Create new form data for second request
          const formData2 = new FormData();
          formData2.append('image', imageBuffer, {
            filename: 'image.jpg',
            contentType: 'image/jpeg'
          });
          
          // Try type recognition endpoint
          endpoint = '/image/recognition/type';
          
          try {
            logmealResponse = await axios.post(
              `${LOGMEAL_API_URL}${endpoint}`,
              formData2,
              {
                headers: {
                  'Authorization': `Bearer ${LOGMEAL_API_KEY}`,
                  ...formData2.getHeaders()
                },
                maxContentLength: Infinity,
                maxBodyLength: Infinity
              }
            );
            
            logmealData = logmealResponse.data;
            console.log('✅ Type recognition successful');
            
          } catch (typeError: any) {
            console.log('⚠️ Type endpoint also failed:', typeError.response?.status || typeError.message);
            console.log('⚠️ Trying complete endpoint as last resort...');
            
            // Try the complete endpoint
            const formData3 = new FormData();
            formData3.append('image', imageBuffer, {
              filename: 'image.jpg',
              contentType: 'image/jpeg'
            });
            
            endpoint = '/image/recognition/complete';
            logmealResponse = await axios.post(
              `${LOGMEAL_API_URL}${endpoint}`,
              formData3,
              {
                headers: {
                  'Authorization': `Bearer ${LOGMEAL_API_KEY}`,
                  ...formData3.getHeaders()
                },
                maxContentLength: Infinity,
                maxBodyLength: Infinity
              }
            );
            
            logmealData = logmealResponse.data;
            console.log('✅ Complete recognition successful');
          }
        }
        
      } catch (fetchError: any) {
        console.error('❌ Network error calling LogMeal API:', fetchError.message);
        
        if (fetchError.response) {
          console.error('❌ Response status:', fetchError.response.status);
          console.error('❌ Response data:', JSON.stringify(fetchError.response.data, null, 2));
        }
        
        return res.status(500).json({ 
          error: 'Network error calling LogMeal API',
          details: fetchError.message,
          status: fetchError.response?.status,
          data: fetchError.response?.data
        });
      }
      
      // With axios, the data is already parsed
      console.log('📊 Response structure:', Object.keys(logmealData || {}));
      console.log('📊 Full response:', JSON.stringify(logmealData, null, 2));
      
      // Process LogMeal response into our format
      const detectedIngredients: any[] = [];
      
      // Map common measurement units
      const getUnitForFood = (foodName: string) => {
        const lowerName = foodName.toLowerCase();
        if (lowerName.includes('rice') || lowerName.includes('pasta')) return 'cup';
        if (lowerName.includes('chicken') || lowerName.includes('beef') || lowerName.includes('pork') || lowerName.includes('steak')) return 'oz';
        if (lowerName.includes('milk') || lowerName.includes('juice') || lowerName.includes('soup')) return 'cup';
        if (lowerName.includes('bread') || lowerName.includes('toast')) return 'slice';
        if (lowerName.includes('egg')) return 'egg';
        if (lowerName.includes('apple') || lowerName.includes('banana') || lowerName.includes('orange')) return 'piece';
        return 'serving';
      };
      
      const getMeasureType = (unit: string) => {
        if (unit === 'cup' || unit === 'tbsp' || unit === 'tsp' || unit === 'ml') return 'volume';
        if (unit === 'oz' || unit === 'g' || unit === 'lb') return 'weight';
        return 'count';
      };
      
      // Process dish recognition response
      if (logmealData.recognition_results) {
        console.log(`🍽️ Found recognition_results array with ${logmealData.recognition_results.length} items`);
        console.log('🔍 Recognition results:', JSON.stringify(logmealData.recognition_results, null, 2));
        
        for (const result of logmealData.recognition_results) {
          console.log('  🔍 Processing result:', result);
          const foodName = result.name || result.food_name || result.class || 'Unknown';
          const confidence = result.prob || result.probability || result.score || 0.5;
          
          console.log(`  📊 Food: ${foodName}, Confidence: ${confidence}`);
          
          // Skip low confidence or generic items
          if (confidence < 0.2) {
            console.log(`  ⚠️ Skipping low confidence: ${confidence}`);
            continue;
          }
          if (foodName.toLowerCase().includes('unknown')) {
            console.log(`  ⚠️ Skipping unknown item`);
            continue;
          }
          
          const unit = getUnitForFood(foodName);
          
          detectedIngredients.push({
            id: `food-${Date.now()}-${Math.random()}`,
            name: foodName,
            confidence: confidence,
            amount: 1,
            unit: unit,
            measureType: getMeasureType(unit),
            source: 'dish'
          });
          
          console.log(`  ✅ Added dish: ${foodName} (${(confidence * 100).toFixed(1)}%)`);
        }
      } else {
        console.log('⚠️ No recognition_results in response');
      }
      
      // Process food type response
      if (logmealData.food_types && Array.isArray(logmealData.food_types)) {
        console.log(`🏷️ Found ${logmealData.food_types.length} food types`);
        
        for (const foodType of logmealData.food_types) {
          if (foodType.name === 'food' && foodType.probs > 0.8) {
            console.log('  ℹ️ Confirmed as food item');
          }
        }
      }
      
      // Process any ingredients if available
      if (logmealData.ingredients) {
        console.log(`🥘 Found ingredients:`, logmealData.ingredients);
        
        for (const ingredient of logmealData.ingredients) {
          const ingredientName = ingredient.name || ingredient;
          const unit = getUnitForFood(ingredientName);
          
          detectedIngredients.push({
            id: `ingredient-${Date.now()}-${Math.random()}`,
            name: ingredientName,
            confidence: 0.8,
            amount: ingredient.quantity || 1,
            unit: unit,
            measureType: getMeasureType(unit),
            source: 'ingredient'
          });
        }
      }
      
      // If we got foodItems array
      if (logmealData.foodItems && Array.isArray(logmealData.foodItems)) {
        console.log(`🍕 Found ${logmealData.foodItems.length} food items`);
        
        for (const item of logmealData.foodItems) {
          const itemName = item.name || item.food_name || item.title;
          if (!itemName) continue;
          
          const confidence = item.confidence || item.score || 0.7;
          const unit = getUnitForFood(itemName);
          
          detectedIngredients.push({
            id: `item-${Date.now()}-${Math.random()}`,
            name: itemName,
            confidence: confidence,
            amount: item.quantity || 1,
            unit: unit,
            measureType: getMeasureType(unit),
            source: 'foodItem'
          });
          
          console.log(`  ✅ Food item: ${itemName} (${(confidence * 100).toFixed(1)}%)`);
        }
      }
      
      // Sort by confidence
      detectedIngredients.sort((a, b) => b.confidence - a.confidence);
      
      // Limit to top 15 detections
      const finalIngredients = detectedIngredients.slice(0, 15);
      
      console.log(`📊 Final detection: ${finalIngredients.length} food items`);
      
      res.json({
        ingredients: finalIngredients,
        raw: {
          hasRecognitionResults: !!logmealData.recognition_results,
          hasFoodTypes: !!logmealData.food_types,
          hasIngredients: !!logmealData.ingredients,
          hasFoodItems: !!logmealData.foodItems
        }
      });
      
    } catch (error) {
      console.error("Error in LogMeal API detection:", error);
      res.status(500).json({ error: "Failed to detect foods with LogMeal" });
    }
  });

  // Test Google Vision API connection
  app.get("/api/test-vision", async (req, res) => {
    try {
      const VISION_API_KEY = 'AIzaSyBZNfvaAwCwgZHi4a9MKs8CkaRaMAxUPm4';
      
      // Test with a minimal request - just check if API is accessible
      const testUrl = `https://vision.googleapis.com/v1/images:annotate?key=${VISION_API_KEY}`;
      
      // Tiny 1x1 red pixel image
      const testImage = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==';
      
      const testRequest = {
        requests: [{
          image: { content: testImage },
          features: [{ type: 'LABEL_DETECTION', maxResults: 1 }]
        }]
      };
      
      console.log('🧪 Testing Vision API with minimal request...');
      
      const response = await fetch(testUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(testRequest)
      });
      
      const responseText = await response.text();
      let responseData;
      try {
        responseData = JSON.parse(responseText);
      } catch {
        responseData = { rawText: responseText };
      }
      
      res.json({
        success: response.ok,
        status: response.status,
        apiKeyWorks: response.status !== 403 && response.status !== 401,
        response: responseData,
        message: response.ok ? 'Vision API is working!' : 'Vision API test failed'
      });
      
    } catch (error: any) {
      console.error('Test error:', error);
      res.json({
        success: false,
        error: error.message,
        apiKeyWorks: false
      });
    }
  });

  // Detect ingredients using Google Vision API
  app.post("/api/detect-ingredients", async (req, res) => {
    try {
      console.log('🔍 === VISION API ENDPOINT CALLED ===');
      const { image } = req.body;
      
      if (!image) {
        console.error('❌ No image data provided');
        return res.status(400).json({ error: "Image data is required" });
      }
      
      console.log('📊 Received image data:', {
        length: image.length,
        isBase64: image.includes('base64'),
        prefix: image.substring(0, 50)
      });
      
      // Google Vision API key
      const VISION_API_KEY = 'AIzaSyBZNfvaAwCwgZHi4a9MKs8CkaRaMAxUPm4';
      const VISION_API_URL = `https://vision.googleapis.com/v1/images:annotate?key=${VISION_API_KEY}`;
      
      console.log('🔑 Using API key:', VISION_API_KEY.substring(0, 10) + '...');
      
      // Remove data URL prefix if present
      const base64Image = image.replace(/^data:image\/\w+;base64,/, '');
      console.log('📦 Base64 image size after cleanup:', base64Image.length);
      
      // Create Vision API request
      const visionRequest = {
        requests: [{
          image: {
            content: base64Image
          },
          features: [
            {
              type: 'OBJECT_LOCALIZATION',
              maxResults: 20
            },
            {
              type: 'LABEL_DETECTION',
              maxResults: 20
            },
            {
              type: 'TEXT_DETECTION',
              maxResults: 10
            }
          ]
        }]
      };
      
      console.log('📡 Calling Google Vision API...');
      console.log('🔗 Vision API URL:', VISION_API_URL);
      
      // Call Vision API
      let visionResponse;
      try {
        visionResponse = await fetch(VISION_API_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(visionRequest)
        });
      } catch (fetchError: any) {
        console.error('❌ Network error calling Vision API:', fetchError.message);
        console.error('Full error:', fetchError);
        return res.status(500).json({ 
          error: 'Network error calling Vision API',
          details: fetchError.message 
        });
      }
      
      if (!visionResponse.ok) {
        const errorText = await visionResponse.text();
        console.error('❌ Vision API HTTP error:', visionResponse.status);
        console.error('❌ Error response:', errorText);
        
        // Try to parse as JSON for better error details
        let errorDetails;
        try {
          errorDetails = JSON.parse(errorText);
          console.error('❌ Error details:', errorDetails);
        } catch {
          errorDetails = { message: errorText };
        }
        
        return res.status(500).json({ 
          error: 'Vision API request failed',
          status: visionResponse.status,
          details: errorDetails
        });
      }
      
      const visionData = await visionResponse.json();
      console.log('✅ Vision API response received');
      
      const response = visionData.responses?.[0];
      if (!response) {
        return res.json({ ingredients: [] });
      }
      
      // Process detections into ingredients
      const detectedIngredients: any[] = [];
      const addedItems = new Set<string>();
      
      // Map common food-related labels to ingredients
      const foodLabelMap: Record<string, string> = {
        'apple': 'apple',
        'banana': 'banana',
        'orange': 'orange',
        'tomato': 'tomato',
        'lettuce': 'lettuce',
        'chicken': 'chicken_breast',
        'beef': 'ground_beef',
        'bread': 'bread',
        'egg': 'eggs',
        'milk': 'milk',
        'cheese': 'cheese',
        'rice': 'white_rice',
        'pasta': 'pasta',
        'potato': 'potato',
        'carrot': 'carrot',
        'onion': 'onion',
        'broccoli': 'broccoli',
        'pepper': 'bell_pepper',
        'fish': 'salmon',
        'shrimp': 'shrimp',
        'pork': 'pork_chop',
        'vegetable': 'vegetables',
        'fruit': 'fruit',
        'meat': 'ground_beef',
        'food': 'food_item',
        'produce': 'vegetables',
        'citrus': 'orange',
        'berry': 'strawberry',
        'nut': 'almonds',
        'grain': 'quinoa',
        'dairy': 'milk',
        'seafood': 'shrimp'
      };
      
      // Process object localizations (with bounding boxes)
      if (response.localizedObjectAnnotations) {
        console.log(`📦 Found ${response.localizedObjectAnnotations.length} objects`);
        
        for (const obj of response.localizedObjectAnnotations) {
          const name = obj.name?.toLowerCase() || '';
          const confidence = obj.score || 0;
          
          // Check if it's a food item
          const ingredientKey = foodLabelMap[name] || (name.includes('food') ? name : null);
          
          if (ingredientKey && confidence > 0.3 && !addedItems.has(ingredientKey)) {
            addedItems.add(ingredientKey);
            
            // Extract bounding box
            const vertices = obj.boundingPoly?.normalizedVertices || [];
            let bbox = null;
            if (vertices.length >= 2) {
              bbox = [
                vertices[0].x || 0,
                vertices[0].y || 0,
                (vertices[2]?.x || vertices[1]?.x || 1) - (vertices[0].x || 0),
                (vertices[2]?.y || vertices[1]?.y || 1) - (vertices[0].y || 0)
              ];
            }
            
            detectedIngredients.push({
              id: `ingredient-${Date.now()}-${Math.random()}`,
              name: ingredientKey.replace(/_/g, ' '),
              confidence: confidence,
              bbox: bbox,
              source: 'object'
            });
            
            console.log(`  ✅ Object: ${name} → ${ingredientKey} (${(confidence * 100).toFixed(1)}%)`);
          }
        }
      }
      
      // Process labels as fallback
      if (response.labelAnnotations && detectedIngredients.length < 5) {
        console.log(`🏷️ Found ${response.labelAnnotations.length} labels`);
        
        for (const label of response.labelAnnotations) {
          const description = label.description?.toLowerCase() || '';
          const confidence = label.score || 0;
          
          // Check if it's a food-related label
          const ingredientKey = foodLabelMap[description];
          
          if (ingredientKey && confidence > 0.5 && !addedItems.has(ingredientKey)) {
            addedItems.add(ingredientKey);
            
            detectedIngredients.push({
              id: `ingredient-${Date.now()}-${Math.random()}`,
              name: ingredientKey.replace(/_/g, ' '),
              confidence: confidence,
              source: 'label'
            });
            
            console.log(`  ✅ Label: ${description} → ${ingredientKey} (${(confidence * 100).toFixed(1)}%)`);
          }
        }
      }
      
      // Process text detection for branded items or labels
      if (response.textAnnotations && response.textAnnotations.length > 0) {
        const fullText = response.textAnnotations[0].description?.toLowerCase() || '';
        console.log(`📝 Detected text: "${fullText.substring(0, 100)}..."`);
        
        // Look for food keywords in text
        const foodKeywords = ['organic', 'fresh', 'natural', 'whole', 'premium'];
        const hasFoodText = foodKeywords.some(keyword => fullText.includes(keyword));
        
        if (hasFoodText) {
          console.log('  ℹ️ Food-related text detected');
        }
      }
      
      // Sort by confidence
      detectedIngredients.sort((a, b) => b.confidence - a.confidence);
      
      // Limit to top 10 detections
      const finalIngredients = detectedIngredients.slice(0, 10);
      
      console.log(`📊 Final detection: ${finalIngredients.length} ingredients`);
      
      res.json({
        ingredients: finalIngredients,
        raw: {
          objects: response.localizedObjectAnnotations?.length || 0,
          labels: response.labelAnnotations?.length || 0,
          hasText: !!response.textAnnotations
        }
      });
      
    } catch (error) {
      console.error("Error in Vision API detection:", error);
      res.status(500).json({ error: "Failed to detect ingredients" });
    }
  });

  // Parse missing foods using GPT (text only, no vision)
  app.post("/api/parse-missing-foods", authenticateToken, async (req: any, res) => {
    try {
      const { text } = req.body;
      
      if (!text || typeof text !== 'string') {
        return res.status(400).json({ message: "Text input is required" });
      }

      const { OpenAI } = await import("openai");
      const openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY
      });

      const completion = await openai.chat.completions.create({
        model: "gpt-3.5-turbo", // Cheaper model for simple text parsing
        messages: [
          {
            role: "system",
            content: `You are a food parser. Parse the user's text and return a JSON array of foods with calories.
            
            Return format:
            [
              {
                "name": "food name",
                "amount": number (grams or ml),
                "unit": "g" or "ml" or "piece",
                "calories": number (for that amount),
                "protein": number (optional, grams),
                "carbs": number (optional, grams),
                "fat": number (optional, grams)
              }
            ]
            
            Common portion sizes:
            - Oil/butter: 10ml (88 calories)
            - Sauce: 30ml (varies)
            - Salt/pepper: 1g (0 calories)
            - Sugar: 5g (20 calories)
            
            Be realistic with portions. Return only valid JSON array.`
          },
          {
            role: "user",
            content: text
          }
        ],
        max_tokens: 300,
        temperature: 0.1
      });

      const content = completion.choices[0].message.content || '[]';
      let foods;
      
      try {
        foods = JSON.parse(content);
      } catch (e) {
        console.error("Failed to parse GPT response:", content);
        foods = [];
      }

      // Add IDs and flags to the foods
      const enhancedFoods = foods.map((food: any, index: number) => ({
        id: `manual_${Date.now()}_${index}`,
        ...food,
        included: true,
        isManual: true
      }));

      res.json(enhancedFoods);
    } catch (error) {
      console.error("Error parsing missing foods:", error);
      res.status(500).json({ message: "Failed to parse foods" });
    }
  });

  // Search food database
  app.get("/api/foods/search", authenticateToken, async (req: any, res) => {
    try {
      const { q } = req.query;
      
      if (!q || typeof q !== 'string') {
        return res.status(400).json({ message: "Search query is required" });
      }

      const foods = await storage.searchFoodDatabase(q);
      res.json(foods);
    } catch (error) {
      console.error("Error searching food database:", error);
      res.status(500).json({ message: "Failed to search foods" });
    }
  });

  // Get nutrition info for a food (uses existing USDA integration)
  app.get("/api/foods/nutrition", authenticateToken, async (req: any, res) => {
    try {
      const { name, amount = 100 } = req.query;
      
      if (!name || typeof name !== 'string') {
        return res.status(400).json({ message: "Food name is required" });
      }

      // First check local database
      const localFood = await storage.getFoodDatabaseItem(name);
      if (localFood) {
        const multiplier = Number(amount) / 100;
        return res.json({
          name: localFood.name,
          amount: Number(amount),
          unit: 'g',
          calories: Math.round((localFood.calories_per_100g || 0) * multiplier),
          protein: Math.round((localFood.protein_per_100g || 0) * multiplier),
          carbs: Math.round((localFood.carbs_per_100g || 0) * multiplier),
          fat: Math.round((localFood.fat_per_100g || 0) * multiplier)
        });
      }

      // If not in local database, try USDA
      if (process.env.USDA_API_KEY) {
        try {
          const searchResponse = await fetch(
            `https://api.nal.usda.gov/fdc/v1/foods/search?query=${encodeURIComponent(name)}&api_key=${process.env.USDA_API_KEY}&pageSize=1`
          );
          
          if (searchResponse.ok) {
            const searchData = await searchResponse.json();
            if (searchData.foods && searchData.foods.length > 0) {
              const food = searchData.foods[0];
              const nutrients = food.foodNutrients || [];
              
              let nutrition = { calories: 0, protein: 0, carbs: 0, fat: 0 };
              
              for (const nutrient of nutrients) {
                const name = (nutrient.nutrientName || '').toLowerCase();
                const value = nutrient.value || 0;
                
                if (name.includes('energy')) nutrition.calories = value;
                if (name.includes('protein')) nutrition.protein = value;
                if (name.includes('carbohydrate')) nutrition.carbs = value;
                if (name.includes('fat') && name.includes('total')) nutrition.fat = value;
              }
              
              // Save to local database for future use
              await storage.createFoodDatabaseItem({
                name: name.toLowerCase(),
                calories_per_100g: nutrition.calories,
                protein_per_100g: nutrition.protein,
                carbs_per_100g: nutrition.carbs,
                fat_per_100g: nutrition.fat,
                common_portion: 100,
                category: null
              }).catch(e => console.log('Could not cache food item'));
              
              const multiplier = Number(amount) / 100;
              return res.json({
                name,
                amount: Number(amount),
                unit: 'g',
                calories: Math.round(nutrition.calories * multiplier),
                protein: Math.round(nutrition.protein * multiplier),
                carbs: Math.round(nutrition.carbs * multiplier),
                fat: Math.round(nutrition.fat * multiplier)
              });
            }
          }
        } catch (usdaError) {
          console.error("USDA API error:", usdaError);
        }
      }

      // Default fallback
      res.json({
        name,
        amount: Number(amount),
        unit: 'g',
        calories: 100, // Default estimate
        protein: 0,
        carbs: 0,
        fat: 0
      });
    } catch (error) {
      console.error("Error getting nutrition info:", error);
      res.status(500).json({ message: "Failed to get nutrition info" });
    }
  });

  // ============= END FOOD TRACKING ENDPOINTS =============

  // Generate meal plan using ChatGPT with caching and rate limiting
  app.post("/api/meal-plan/generate", authenticateToken, async (req: any, res) => {
    const startTime = Date.now(); // Fix: Define startTime
    try {
      // User is now authenticated through middleware, get userId from req.user
      const userId = req.user?.id;
      
      if (!userId) {
        return res.status(401).json({ message: "Authentication required" });
      }

      // Check rate limit
      if (!rateLimiter.isAllowed(userId)) {
        return res.status(429).json({
          message: "Rate limit exceeded. Please try again later.",
          remainingRequests: rateLimiter.getRemainingRequests(userId),
          resetTime: rateLimiter.getResetTime(userId)
        });
      }

      const {
        numDays,
        mealsPerDay,
        cookTime,
        difficulty,
        nutritionGoal,
        dietaryRestrictions,
        availableIngredients,
        excludeIngredients,
        primaryGoal,
        selectedFamilyMembers = [],
        useIntelligentPrompt = true,
        culturalBackground = [],
        planTargets = ["Everyone"] // New parameter for family member targeting (array)
      } = req.body;

      // Disable caching - always generate fresh meal plans
        // const cacheKey = JSON.stringify({
        //   numDays,
        //   mealsPerDay,
        //   cookTime,
        //   difficulty,
        //   nutritionGoal,
        //   dietaryRestrictions,
        //   availableIngredients,
        //   excludeIngredients,
        //   primaryGoal,
        //   selectedFamilyMembers: selectedFamilyMembers?.sort(),
        //   useIntelligentPrompt
        // });

        // const cachedResult = getCachedMealPlan(cacheKey);
        // if (cachedResult) {
        //   console.log('Serving cached meal plan');
        //   return res.json(cachedResult);
        // }

      // Get user profile for intelligent prompt building
      let userProfile = null;
      let culturalCuisineData = null;
      try {
        if (userId !== 'anonymous' && useIntelligentPrompt) {
          console.log('Attempting to fetch user profile for userId:', userId);
          // Pass userId as string, no parseInt needed since user_id is varchar in database
          userProfile = await storage.getProfile(userId);
          console.log('User profile found:', userProfile);

          // Get cultural cuisine data if user has cultural preferences
          if (userProfile && userProfile.cultural_background && Array.isArray(userProfile.cultural_background) && userProfile.cultural_background.length > 0) {
            console.log('User has cultural background:', userProfile.cultural_background);
            const { getCachedCulturalCuisine } = await import('./cultureCacheManager');
            // Pass userId as string
            culturalCuisineData = await getCachedCulturalCuisine(userId, userProfile.cultural_background);
            console.log(`Retrieved cultural cuisine data for: ${userProfile.cultural_background.join(', ')}`);
            console.log('Cultural cuisine data structure:', Object.keys(culturalCuisineData || {}));
          }
        } else {
          console.log('Skipping user profile fetch - userId:', userId, 'useIntelligentPrompt:', useIntelligentPrompt);
        }
      } catch (error) {
        console.log('Could not fetch user profile, using basic prompt. Error:', error);
      }

      let prompt;

      // Generate day structure for all cases
      const dayStructure = [];
      for (let i = 1; i <= numDays; i++) {
        dayStructure.push(`"day_${i}"`);
      }

      // ALWAYS use V2 intelligent prompt builder
      if (true) {
        // Import profile validator
        const { validateProfileForMealGeneration, getDefaultGoalWeights } = await import('./profileValidator');
        
        // For anonymous users, create a minimal profile with defaults
        if (userId === 'anonymous') {
          // Create a minimal profile for anonymous users
          userProfile = {
            primary_goal: primaryGoal || 'Eat Healthier',
            profile_type: 'individual',
            family_size: 1,
            preferences: dietaryRestrictions ? dietaryRestrictions.split(',').map((r: string) => r.trim()) : [],
            cultural_background: culturalBackground || [],
            goal_weights: getDefaultGoalWeights(primaryGoal || 'Eat Healthier')
          };
          console.log('Created default profile for anonymous user');
        } else if (!userProfile) {
          // For logged-in users, profile is required
          return res.status(400).json({
            message: "Profile not found. Please update your profile before generating meal plans.",
            error: "PROFILE_MISSING"
          });
        }
        
        // Process goal weights from profile before validation
        if (userProfile && userProfile.goals && Array.isArray(userProfile.goals)) {
          const goalWeights: any = {};
          
          // Parse goals array into weights object
          userProfile.goals.forEach((goal: string) => {
            if (typeof goal === 'string' && goal.includes(':')) {
              const [key, value] = goal.split(':');
              const weight = parseFloat(value);
              if (!isNaN(weight)) {
                goalWeights[key] = weight;
              }
            }
          });
          
          // Add parsed weights to profile for validation
          userProfile.goal_weights = goalWeights;
          console.log('Parsed goal weights from goals array:', goalWeights);
        }
        
        // Validate profile has required fields
        if (userProfile) {
          const validation = validateProfileForMealGeneration(userProfile);
          if (!validation.isValid) {
            return res.status(400).json({
              message: validation.errorMessage,
              missingFields: validation.missingFields,
              error: "PROFILE_INCOMPLETE"
            });
          }
        }
        
        // Use V2 intelligent prompt builder
        const { buildIntelligentPrompt } = await import('./intelligentPromptBuilderV2');
        const { mergeFamilyDietaryRestrictions } = await import('../shared/schema');

        // Merge dietary restrictions from profile and family members
        const profileRestrictions = userProfile?.preferences || [];
        const familyMembers = Array.isArray(userProfile?.members) ? userProfile.members : [];
        const familyRestrictions = mergeFamilyDietaryRestrictions(familyMembers);
        
        // Combine all restrictions: request > family > profile
        const allRestrictions = new Set<string>();
        
        // Add request restrictions (highest priority)
        if (dietaryRestrictions) {
          dietaryRestrictions.split(',').forEach((r: string) => {
            const trimmed = r.trim();
            if (trimmed) allRestrictions.add(trimmed);
          });
        }
        
        // Add family member restrictions
        if (Array.isArray(familyRestrictions)) {
          familyRestrictions.forEach((r: string) => allRestrictions.add(r));
        }
        
        // Add profile restrictions
        if (Array.isArray(profileRestrictions)) {
          profileRestrictions.forEach((r: string) => allRestrictions.add(r));
        }
        
        const mergedRestrictions = Array.from(allRestrictions).join(', ');
        console.log('Merged dietary restrictions:', mergedRestrictions);

        // Ensure we have goal weights (use defaults if not in profile)
        const goalWeights = userProfile?.goal_weights || getDefaultGoalWeights(primaryGoal || userProfile?.primary_goal || 'Eat Healthier');
        
        const filters = {
          numDays,
          mealsPerDay,
          cookTime,
          difficulty,
          nutritionGoal,
          dietaryRestrictions: mergedRestrictions, // Use merged restrictions
          availableIngredients,
          excludeIngredients,
          primaryGoal: primaryGoal || userProfile?.primary_goal || 'Eat Healthier', // Ensure we always have a primary goal
          familySize: userProfile?.family_size || undefined,
          familyMembers: familyMembers,
          profileType: userProfile?.profile_type as 'individual' | 'family' || 'individual',
          // UNIFIED: Set intelligent defaults based on primary goal across entire system
          encourageOverlap: primaryGoal === 'Save Money' || userProfile?.primary_goal === 'Save Money',
          availableIngredientUsagePercent: primaryGoal === 'Save Money' ? 80 : 60,
          // Add cultural cuisine data
          culturalCuisineData: culturalCuisineData,
          culturalBackground: userProfile?.cultural_background || culturalBackground || [],
          // V2 specific fields
          goalWeights: goalWeights,
          weightBasedEnhanced: true, // Enable V2 weight-based system
          heroIngredients: [] // Will be populated by V2 system
        };

        prompt = await buildIntelligentPrompt(filters);
        console.log('Using V2 intelligent prompt builder with enhanced features');
        
        // Log prompt details for debugging
        console.log('Primary Goal:', filters.primaryGoal);
        console.log('Goal Weights:', filters.goalWeights);
        console.log('Weight-based Enhanced:', filters.weightBasedEnhanced);
      }

      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            {
              role: 'system',
              content: `You are a meal planning expert. You MUST generate exactly the requested number of days. Follow the user's specifications precisely and generate complete meal plans with all requested days. Always return valid JSON.`
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          response_format: { type: "json_object" },
          temperature: 0.2, // Lower for more consistent adherence to requirements
          max_tokens: 4000 // Increased to ensure all days fit
        })
      });

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status}`);
      }

      const data: any = await response.json();
      let mealPlan;

      try {
        const content = data.choices[0].message.content;
        if (!content || content.trim() === '') {
          throw new Error('Empty response from AI');
        }
        mealPlan = JSON.parse(content);
      } catch (parseError) {
        console.error('JSON Parse Error:', parseError);
        console.error('AI Response:', data.choices[0].message.content);
        throw new Error('Invalid response format from AI. Please try again.');
      }

      // Validate the meal plan structure
      if (!mealPlan.meal_plan || typeof mealPlan.meal_plan !== 'object') {
        throw new Error('Invalid meal plan structure - missing meal_plan object');
      }

      // Apply difficulty rounding and validation
      validateAndRoundDifficulties(mealPlan.meal_plan, difficulty);

      // DIETARY VALIDATION: Check meal plan compliance before caching
      let finalMealPlan = mealPlan;
      if (dietaryRestrictions) {
        try {
          const { validateMealPlanDietaryCompliance } = await import('./dietaryValidationService');

          const validation = await validateMealPlanDietaryCompliance(mealPlan, [dietaryRestrictions]);
          console.log(`🔍 Meal plan dietary validation: ${validation.overallCompliance}% compliance (${validation.compliantMeals}/${validation.totalMeals} meals)`);

          if (validation.overallCompliance < 80) {
            console.warn(`❌ Low dietary compliance for "${dietaryRestrictions}":`, validation.summary);

            // Add validation metadata to meal plan
            finalMealPlan.dietary_validation = {
              compliance_score: validation.overallCompliance,
              compliant_meals: validation.compliantMeals,
              total_meals: validation.totalMeals,
              violations_summary: validation.summary,
              validation_timestamp: new Date().toISOString()
            };

            // Log specific violations for debugging
            Object.entries(validation.violations).forEach(([mealKey, result]) => {
              console.warn(`  - ${mealKey}: ${result.violations.length} violations`);
            });
          } else {
            console.log(`✅ Meal plan passes dietary validation for "${dietaryRestrictions}" (${validation.overallCompliance}% compliance)`);
            finalMealPlan.dietary_validation = {
              compliance_score: validation.overallCompliance,
              compliant_meals: validation.compliantMeals,
              total_meals: validation.totalMeals,
              validation_timestamp: new Date().toISOString()
            };
          }
        } catch (validationError) {
          console.error('Meal plan dietary validation error:', validationError);
          // Continue without validation rather than failing
        }
      }

      // DISH NAME ENHANCEMENT: Map to familiar, recognizable names
      try {
        const { enhanceMealPlanNames } = await import('./mealPlanEnhancer');

        // Extract cultural background from profile or request body
        const culturalBackgroundArray = userProfile?.cultural_background || [];

        const enhancement = await enhanceMealPlanNames(
          finalMealPlan,
          culturalBackgroundArray as string[]
        );

        console.log(`📝 Meal plan enhancement: ${enhancement.enhancementStats.familiarNameChanges} name changes, ${enhancement.enhancementStats.cuisineCorrections} cuisine corrections`);
        console.log(`   Average naming confidence: ${(enhancement.enhancementStats.averageConfidence * 100).toFixed(1)}%`);

        if (enhancement.enhancementStats.familiarNameChanges > 0) {
          finalMealPlan = enhancement.enhancedMealPlan;
          console.log('   Enhanced meal names:');
          enhancement.enhancementLog.slice(0, 3).forEach(log => console.log(`     ${log}`));
        }

      } catch (enhancementError) {
        console.error('Meal plan enhancement error:', enhancementError);
        // Continue without enhancement rather than failing
      }

      const dayCount = Object.keys(finalMealPlan.meal_plan).length;
      console.log(`Generated meal plan has ${dayCount} days, expected ${numDays}`);

      // Ensure we have the correct number of days
      if (dayCount !== numDays) {
        console.error(`CRITICAL ERROR: Day count mismatch: generated ${dayCount}, expected ${numDays}`);
        throw new Error(`AI generated ${dayCount} days instead of requested ${numDays} days. Please try again.`);
      }

      // Disable caching - always generate fresh meal plans
      console.log(`✅ Generated fresh meal plan in ${Date.now() - startTime}ms (no caching)`);
      res.json(finalMealPlan);

    } catch (error) {
      console.error("Error generating meal plan:", error);
      res.status(500).json({ message: "Failed to generate meal plan" });
    }
  });

  // Streaming meal plan generation endpoint - streams actual meal content
  app.post("/api/meal-plan/generate-stream", authenticateToken, async (req: any, res) => {
    // Set headers for Server-Sent Events
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');
    res.setHeader('Access-Control-Allow-Origin', '*');
    
    // Helper function to send SSE data
    const sendData = (data: string) => {
      res.write(`data: ${data}\n\n`);
    };

    try {
      const userId = req.user?.id;
      
      if (!userId) {
        sendData(JSON.stringify({ error: 'Authentication required' }));
        return res.end();
      }

      // Check rate limit
      if (!rateLimiter.isAllowed(userId)) {
        sendData(JSON.stringify({ 
          error: 'Rate limit exceeded. Please try again later.',
          remainingRequests: rateLimiter.getRemainingRequests(userId),
          resetTime: rateLimiter.getResetTime(userId)
        }));
        return res.end();
      }

      const {
        numDays,
        mealsPerDay,
        cookTime,
        difficulty,
        nutritionGoal,
        dietaryRestrictions,
        availableIngredients,
        excludeIngredients,
        primaryGoal,
        selectedFamilyMembers = [],
        useIntelligentPrompt = true,
        culturalBackground = [],
        planTargets = ["Everyone"]
      } = req.body;

      // Get user profile and cultural data
      let userProfile = null;
      let culturalCuisineData = null;
      
      try {
        if (userId !== 'anonymous' && useIntelligentPrompt) {
          userProfile = await storage.getProfile(userId);
          console.log('Streaming: User profile found:', userProfile?.profile_name);
          
          if (userProfile && userProfile.cultural_background && Array.isArray(userProfile.cultural_background) && userProfile.cultural_background.length > 0) {
            const { getCachedCulturalCuisine } = await import('./cultureCacheManager');
            culturalCuisineData = await getCachedCulturalCuisine(userId, userProfile.cultural_background);
            console.log(`Streaming: Retrieved cultural cuisine data for: ${userProfile.cultural_background.join(', ')}`);
          }
        }
      } catch (error) {
        console.log('Streaming: Could not fetch user profile, using basic prompt. Error:', error);
      }

      // Process goal weights from profile
      let goalWeights: any = {};
      if (userProfile && userProfile.goals && Array.isArray(userProfile.goals)) {
        userProfile.goals.forEach((goal: string) => {
          if (typeof goal === 'string' && goal.includes(':')) {
            const [key, value] = goal.split(':');
            const weight = parseFloat(value);
            if (!isNaN(weight)) {
              goalWeights[key] = weight;
            }
          }
        });
        userProfile.goal_weights = goalWeights;
      }

      // Validate profile and build prompt
      const { validateProfileForMealGeneration, getDefaultGoalWeights } = await import('./profileValidator');
      
      if (userId === 'anonymous') {
        userProfile = {
          primary_goal: primaryGoal || 'Eat Healthier',
          profile_type: 'individual',
          family_size: 1,
          preferences: dietaryRestrictions ? dietaryRestrictions.split(',').map((r: string) => r.trim()) : [],
          cultural_background: culturalBackground || [],
          goal_weights: getDefaultGoalWeights(primaryGoal || 'Eat Healthier')
        };
      } else if (!userProfile) {
        sendData(JSON.stringify({ error: 'Profile not found. Please update your profile before generating meal plans.' }));
        return res.end();
      }
      
      // Validate profile
      if (userProfile) {
        const validation = validateProfileForMealGeneration(userProfile);
        if (!validation.isValid) {
          sendData(JSON.stringify({ 
            error: validation.errorMessage,
            missingFields: validation.missingFields
          }));
          return res.end();
        }
      }
      
      // Build intelligent prompt
      const { buildIntelligentPrompt } = await import('./intelligentPromptBuilderV2');
      const { mergeFamilyDietaryRestrictions } = await import('../shared/schema');
      
      const dietaryRestrictionsArray = typeof dietaryRestrictions === 'string' 
        ? dietaryRestrictions.split(',').map((r: string) => r.trim()).filter(Boolean)
        : dietaryRestrictions || [];
      
      // Merge dietary restrictions from profile and family members  
      const profileRestrictions = userProfile?.preferences || [];
      const familyMembers = Array.isArray(userProfile?.members) ? userProfile.members : [];
      const familyRestrictions = mergeFamilyDietaryRestrictions(familyMembers);
      
      // Combine all restrictions: request > family > profile
      const allRestrictions = new Set<string>();
      
      // Add request restrictions (highest priority)
      if (dietaryRestrictions) {
        dietaryRestrictionsArray.forEach((r: string) => {
          if (r.trim()) allRestrictions.add(r.trim());
        });
      }
      
      // Add family restrictions (medium priority)
      familyRestrictions.forEach(r => allRestrictions.add(r));
      
      // Add profile restrictions (lowest priority)
      profileRestrictions.forEach(r => allRestrictions.add(r));
      
      const mergedRestrictions = Array.from(allRestrictions).join(', ');

      const prompt = await buildIntelligentPrompt({
        numDays,
        mealsPerDay,
        cookTime,
        difficulty,
        nutritionGoal,
        dietaryRestrictions: mergedRestrictions,
        availableIngredients,
        excludeIngredients,
        primaryGoal: primaryGoal || userProfile?.primary_goal || 'Eat Healthier',
        familySize: userProfile?.family_size || undefined,
        familyMembers: familyMembers,
        profileType: userProfile?.profile_type as 'individual' | 'family' || 'individual',
        encourageOverlap: primaryGoal === 'Save Money' || userProfile?.primary_goal === 'Save Money',
        availableIngredientUsagePercent: primaryGoal === 'Save Money' ? 80 : 60,
        culturalCuisineData: culturalCuisineData,
        culturalBackground: userProfile?.cultural_background || culturalBackground || [],
        goalWeights: goalWeights,
        weightBasedEnhanced: true,
        heroIngredients: []
      });

      // Stream from OpenAI
      const OpenAI = (await import('openai')).default;
      const openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY
      });
      
      const openaiStream = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [{ role: "user", content: prompt }],
        stream: true,
        temperature: 0.7,
        max_tokens: 4096
      });

      // Parse meals in real-time from the stream
      let buffer = '';
      let mealCount = 0;
      let currentDay = 0;
      const mealTypes = ['breakfast', 'lunch', 'dinner'];
      const processedMeals = new Set<string>(); // Track processed meals to avoid duplicates
      
      // Helper to extract meal type from position
      const getMealType = (dayNum: number, mealNum: number) => {
        const mealIndex = (mealNum - 1) % mealsPerDay;
        return mealTypes[mealIndex] || 'meal';
      };

      for await (const chunk of openaiStream) {
        const content = chunk.choices[0]?.delta?.content || '';
        if (content) {
          buffer += content;
          
          // Only log when we see a title being streamed
          if (content.includes('"title"')) {
            console.log('📡 Title found in stream:', content);
          }
          
          // Track current day from the JSON structure
          const dayMatches = [...buffer.matchAll(/"day_(\d+)"/g)];
          if (dayMatches.length > 0) {
            currentDay = parseInt(dayMatches[dayMatches.length - 1][1]);
          }
          
          // Look for complete meal objects with "title" field
          const mealRegex = /"title":\s*"([^"]+)"[^}]*"cook_time_minutes":\s*(\d+)[^}]*"difficulty":\s*(\d+)/g;
          
          // Only search for meals in new content since last processed position
          let lastSearchPosition = buffer.length - content.length;
          mealRegex.lastIndex = Math.max(0, lastSearchPosition - 200); // Search a bit before new content
          
          let match;
          while ((match = mealRegex.exec(buffer)) !== null) {
            const [fullMatch, mealTitle, cookTime, difficulty] = match;
            
            // Create a unique key based on meal title and position in buffer
            const mealPosition = buffer.indexOf(fullMatch);
            const mealKey = `${mealTitle}_${mealPosition}`;
            
            // Skip if we've already processed this exact meal at this position
            if (processedMeals.has(mealKey)) {
              console.log(`⏭️ Skipping duplicate meal: ${mealTitle} at position ${mealPosition}`);
              continue;
            }
            
            // Determine meal type based on count
            const mealType = mealTypes[mealCount % 3];
            
            processedMeals.add(mealKey);
            mealCount++;
            
            console.log(`🍽️ NEW MEAL FOUND: ${mealTitle} (${mealType}) - Count: ${mealCount}`);
            
            // Send individual meal as SSE event immediately
            const mealData = {
              title: mealTitle,
              name: mealTitle, // For compatibility
              cook_time_minutes: parseInt(cookTime),
              cook_time: parseInt(cookTime), // For compatibility
              prep_time: 10, // Default prep time
              difficulty: parseInt(difficulty),
              mealType: mealType,
              day: currentDay || 1,
              totalTime: parseInt(cookTime) + 10,
              id: `${mealType}_${mealCount}_${Date.now()}`
            };
            
            sendData(JSON.stringify({
              type: 'meal',
              data: mealData
            }));
          }
        }
      }
      
      // Send the complete meal plan at the end
      try {
        // Clean and parse the complete response
        const cleanBuffer = buffer.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        const completeMealPlan = JSON.parse(cleanBuffer);
        
        sendData(JSON.stringify({
          type: 'complete',
          data: completeMealPlan
        }));
      } catch (e) {
        // If parsing fails, just send done signal
        sendData(JSON.stringify({ type: 'done' }));
      }
      
      res.end();
      
    } catch (error) {
      console.error('Streaming generation error:', error);
      sendData(JSON.stringify({ error: error instanceof Error ? error.message : 'Failed to generate meal plan' }));
      res.end();
    }
  });

  // Weight-based meal plan generation
  app.post("/api/meal-plan/generate-weight-based", authenticateToken, async (req: any, res) => {
    const startTime = Date.now();
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      // Check rate limit
      if (!rateLimiter.isAllowed(userId.toString())) {
        return res.status(429).json({
          message: "Rate limit exceeded. Please try again later.",
          remainingRequests: rateLimiter.getRemainingRequests(userId.toString()),
          resetTime: rateLimiter.getResetTime(userId.toString())
        });
      }

      const {
        numDays,
        mealsPerDay,
        goalWeights,
        dietaryRestrictions = [],
        culturalBackground = [],
        availableIngredients = "",
        excludeIngredients = "",
        familySize = 2,
        planTargets = ["Everyone"] // New parameter for family member targeting (array)
      } = req.body;

      // Get weight-based profile and user profile for advanced prompt integration
      let weightBasedProfile = null;
      let userProfile = null;
      let culturalCuisineData = null;
      
      try {
        userProfile = await storage.getProfile(userId);
        console.log('Retrieved user profile for weight-based system:', userProfile?.profile_name);
        
        if (userProfile && userProfile.profile_type === 'weight-based') {
          // Parse goal weights from stored goals
          const storedGoalWeights: any = {};
          if (userProfile.goals && Array.isArray(userProfile.goals)) {
            userProfile.goals.forEach((goal: string) => {
              const [key, value] = goal.split(':');
              storedGoalWeights[key] = parseFloat(value) || 0.5;
            });
          }
          
          weightBasedProfile = {
            profileName: userProfile.profile_name,
            familySize: userProfile.family_size,
            goalWeights: storedGoalWeights,
            dietaryRestrictions: userProfile.preferences || [],
            culturalBackground: userProfile.cultural_background || []
          };
        }

        // Get cultural cuisine data if user has cultural preferences (for advanced prompt integration)
        if (userProfile && userProfile.cultural_background && Array.isArray(userProfile.cultural_background) && userProfile.cultural_background.length > 0) {
          console.log('Weight-based system: User has cultural background:', userProfile.cultural_background);
          const { getCachedCulturalCuisine } = await import('./cultureCacheManager');
          culturalCuisineData = await getCachedCulturalCuisine(userId, userProfile.cultural_background);
          console.log(`Weight-based system: Retrieved cultural cuisine data for: ${userProfile.cultural_background.join(', ')}`);
        }
      } catch (error) {
        console.log('Could not fetch user profile for weight-based system, using request data. Error:', error);
      }

      // Import helper function
      const { mergeFamilyDietaryRestrictions } = await import('../shared/schema');
      
      // Merge dietary restrictions from all sources
      const allRestrictions = new Set<string>();
      
      // Add weight-based profile restrictions
      if (weightBasedProfile?.dietaryRestrictions && Array.isArray(weightBasedProfile.dietaryRestrictions)) {
        weightBasedProfile.dietaryRestrictions.forEach((r: string) => allRestrictions.add(r));
      }
      
      // Add traditional profile restrictions (preferences field)
      if (userProfile?.preferences && Array.isArray(userProfile.preferences)) {
        userProfile.preferences.forEach(r => allRestrictions.add(r));
      }
      
      // Add family member restrictions if traditional profile
      if (userProfile?.members && Array.isArray(userProfile.members)) {
        const familyRestrictions = mergeFamilyDietaryRestrictions(userProfile.members);
        familyRestrictions.forEach(r => allRestrictions.add(r));
      }
      
      // Add request restrictions (highest priority)
      if (dietaryRestrictions && Array.isArray(dietaryRestrictions)) {
        dietaryRestrictions.forEach((r: any) => {
          if (r && r.trim()) allRestrictions.add(r.trim());
        });
      }
      
      const mergedDietaryRestrictions = Array.from(allRestrictions);
      console.log('Weight-based system - Merged dietary restrictions:', mergedDietaryRestrictions);

      // MEMBER-SPECIFIC FILTERING: Apply planTargets filtering for specific family members
      let targetMemberRestrictions = mergedDietaryRestrictions;
      let targetMemberNames = planTargets;
      
      if (!planTargets.includes("Everyone") && userProfile?.members && Array.isArray(userProfile.members)) {
        console.log(`🎯 Filtering meal plan for specific members: "${planTargets.join(', ')}"`);
        
        // Collect restrictions from all selected members
        const memberRestrictions = new Set<string>();
        
        planTargets.forEach(targetName => {
          const targetMember = userProfile.members.find((member: any) => member.name === targetName);
          
          if (targetMember) {
            console.log(`✅ Found target member: ${targetName}`, targetMember);
            
            // Add member's specific dietary restrictions
            if (targetMember.dietaryRestrictions && Array.isArray(targetMember.dietaryRestrictions)) {
              targetMember.dietaryRestrictions.forEach((restriction: string) => {
                if (restriction && restriction.trim()) {
                  memberRestrictions.add(restriction.trim());
                }
              });
            }
            
            // Also check preferences for dietary restrictions (backward compatibility)
            if (targetMember.preferences && Array.isArray(targetMember.preferences)) {
              targetMember.preferences.forEach((pref: string) => {
                const lowerPref = pref.toLowerCase().trim();
                if (lowerPref.includes('allerg') || lowerPref.includes('intoleran') || 
                    lowerPref.includes('free') || lowerPref.includes('vegan') || 
                    lowerPref.includes('vegetarian') || lowerPref.includes('kosher') ||
                    lowerPref.includes('halal') || lowerPref.includes('diet')) {
                  memberRestrictions.add(pref.trim());
                }
              });
            }
          } else {
            console.warn(`⚠️ Could not find family member "${targetName}", skipping`);
          }
        });
        
        // Still include request-level restrictions (highest priority)
        if (dietaryRestrictions && Array.isArray(dietaryRestrictions)) {
          dietaryRestrictions.forEach((r: any) => {
            if (r && r.trim()) memberRestrictions.add(r.trim());
          });
        }
        
        targetMemberRestrictions = Array.from(memberRestrictions);
        console.log(`🎯 Combined restrictions for selected members [${planTargets.join(', ')}]:`, targetMemberRestrictions);
        
      } else if (!planTargets.includes("Everyone") && planTargets.length > 0) {
        console.log(`ℹ️ Plan targets "${planTargets.join(', ')}" specified but no family members found, using merged restrictions`);
      }

      // Use profile data or fallback to request data
      const finalGoalWeights = goalWeights || weightBasedProfile?.goalWeights || {
        cost: 0.5, health: 0.5, cultural: 0.5, variety: 0.5, time: 0.5
      };
      const finalDietaryRestrictions = targetMemberRestrictions; // Use member-filtered restrictions
      const finalCulturalBackground = culturalBackground.length > 0 ? 
        culturalBackground : (weightBasedProfile?.culturalBackground || []);
      // Adjust final family size based on plan targets
      let finalFamilySize;
      if (!planTargets.includes("Everyone") && userProfile?.members && Array.isArray(userProfile.members)) {
        // Count how many valid target members we found
        const validTargetCount = planTargets.filter(targetName => 
          userProfile.members.find((member: any) => member.name === targetName)
        ).length;
        
        if (validTargetCount > 0) {
          finalFamilySize = validTargetCount; // Size based on selected members
          console.log(`🎯 Final family size set to ${validTargetCount} for selected members: ${planTargets.join(', ')}`);
        } else {
          finalFamilySize = familySize || weightBasedProfile?.familySize || 2;
        }
      } else {
        finalFamilySize = familySize || weightBasedProfile?.familySize || 2;
      }

      // Initialize weight-based meal planner
      const { WeightBasedMealPlanner } =  await import('./WeightBasedMealPlanner');
      const planner = new WeightBasedMealPlanner();

      // Get hero ingredients for cost optimization
      let heroIngredients: string[] = [];
      if (finalGoalWeights.cost > 0.6) {
        const { HeroIngredientManager } = await import('./HeroIngredientManager');
        const heroManager = new HeroIngredientManager();
        const heroSelection = await heroManager.selectHeroIngredients(
          finalCulturalBackground,
          availableIngredients.split(',').map((i: string) => i.trim()).filter(Boolean),
          finalGoalWeights.cost,
          finalDietaryRestrictions
        );
        heroIngredients = Array.isArray(heroSelection?.selected_ingredients) ? 
          heroSelection.selected_ingredients.map(ing => ing.name) : [];
        console.log('Selected hero ingredients:', heroIngredients);
      }

      // V2 INTEGRATION: Use Prompt Builder V2 with main goal + weight-based enhancement
      let prompt: string;
      
      // Extract main goal from profile for advanced prompt integration
      const primaryGoal = userProfile?.primary_goal || 'Weight-Based Planning';
      console.log('Weight-based system: Processing main goal:', primaryGoal);
      
      try {
        // Import V2 prompt builder with weight-based intelligence
        const { buildWeightBasedIntelligentPrompt } = await import('./intelligentPromptBuilderV2');
        
        // Build advanced filters for V2 prompt builder
        const advancedFilters = {
          numDays,
          mealsPerDay,
          cookTime: 45, // Default reasonable cook time
          difficulty: 3, // Default moderate difficulty  
          primaryGoal,
          familySize: finalFamilySize,
          familyMembers: Array.isArray(userProfile?.members) ? userProfile.members : [],
          profileType: userProfile?.profile_type as 'individual' | 'family' || 'individual',
          dietaryRestrictions: finalDietaryRestrictions.join(', '),
          culturalBackground: finalCulturalBackground,
          culturalCuisineData: culturalCuisineData,
          availableIngredients,
          excludeIngredients,
          // Member targeting
          planTargets: planTargets,
          targetMemberNames: targetMemberNames,
          // Weight-based enhancements
          goalWeights: finalGoalWeights,
          heroIngredients,
          weightBasedEnhanced: true
        };
        
        // Generate prompt using V2 system (main goals + weight-based intelligence)
        prompt = await buildWeightBasedIntelligentPrompt(
          advancedFilters,
          finalGoalWeights,
          heroIngredients
        );
        
        console.log('✅ Generated V2 weight-based prompt with main goal integration');
        console.log('Main goal:', primaryGoal);
        console.log('Goal weights:', finalGoalWeights);
        console.log('Hero ingredients:', heroIngredients);
        
      } catch (error) {
        console.error('V2 prompt builder failed, falling back to original weight-based prompt:', error);
        
        // Fallback to original weight-based prompt system
        const mealContext = {
          numDays,
          mealsPerDay,
          availableIngredients,
          excludeIngredients,
          familySize: finalFamilySize
        };

        prompt = (planner as any).buildWeightBasedPrompt(
          finalGoalWeights,
          heroIngredients,
          mealContext,
          finalDietaryRestrictions,
          finalFamilySize
        );
        
        console.log('⚠️ Using fallback weight-based prompt');
        console.log('Goal weights:', finalGoalWeights);
        console.log('Hero ingredients:', heroIngredients);
      }

      // Generate meal plan using OpenAI
      const openai = new (await import('openai')).OpenAI({
        apiKey: process.env.OPENAI_API_KEY
      });

      const completion = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [
          {
            role: 'system',
            content: `You are an advanced meal planning expert with weight-based intelligence. You understand main goals (like "${primaryGoal}") and can apply weight-based priorities to refine decisions. ${!planTargets.includes("Everyone") ? `This meal plan is specifically designed for "${planTargets.join(', ')}" with their combined dietary restrictions and preferences.` : 'This meal plan is designed for the entire family with merged dietary restrictions.'} Generate exactly the requested number of days following the main goal guidance first, then using weights to resolve conflicts. Always return valid JSON with proper day structure.`
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        response_format: { type: "json_object" },
        temperature: 0.3,
        max_tokens: 4000
      });

      let mealPlan;
      try {
        mealPlan = JSON.parse(completion.choices[0].message.content || '{}');
      } catch (parseError) {
        console.error('Failed to parse AI response:', parseError);
        throw new Error('Invalid response format from AI');
      }

      // Validate and enhance meal plan with cultural meal integration
      if (finalGoalWeights.cultural > 0.3 && finalCulturalBackground.length > 0) {
        const { SmartCulturalMealSelector } = await import('./SmartCulturalMealSelector');
        const culturalSelector = new SmartCulturalMealSelector();
        
        try {
          const culturalMeals = await (culturalSelector as any).getCompatibleCulturalMeals(
            userId,
            finalCulturalBackground,
            finalDietaryRestrictions
          );
          
          if (culturalMeals.length > 0) {
            // Integrate cultural meals into the plan
            const enhancedPlan = await (culturalSelector as any).integrateCulturalMeals(
              mealPlan,
              culturalMeals,
              finalGoalWeights,
              { numDays, mealsPerDay }
            );
            mealPlan = enhancedPlan;
            console.log('Enhanced meal plan with cultural integration');
          }
        } catch (culturalError) {
          console.log('Cultural meal integration failed, using basic plan:', culturalError);
        }
      }

      // Add metadata about the V2 weight-based generation
      const finalMealPlan = {
        ...mealPlan,
        generation_metadata: {
          type: 'weight-based-v2',
          main_goal: primaryGoal,
          goal_weights: finalGoalWeights,
          hero_ingredients: heroIngredients,
          cultural_integration: finalGoalWeights.cultural > 0.3,
          advanced_prompt_used: true,
          prompt_builder_version: 'V2',
          generation_time_ms: Date.now() - startTime
        }
      };

      console.log(`✅ Generated weight-based meal plan in ${Date.now() - startTime}ms`);
      res.json(finalMealPlan);

    } catch (error) {
      console.error("Error generating weight-based meal plan:", error);
      res.status(500).json({ message: "Failed to generate weight-based meal plan" });
    }
  });

  // Cache statistics endpoint
  app.get("/api/cache/stats", (req, res) => {
    // Temporary mock stats while caching is disabled
    res.json({
      cacheSize: 0,
      hitRate: "0.0%",
      estimatedSavings: "$0.0000 per request"
    });
  });

  // Optimized shopping list endpoint
  app.post("/api/shopping-list/optimize", async (req, res) => {
    try {
      const { mealPlan, userPreferences } = req.body;

      if (!mealPlan) {
        return res.status(400).json({ message: "Meal plan data is required" });
      }

      const { createOptimizedShoppingList } = await import("./instacart");
      const optimizedData = await createOptimizedShoppingList(mealPlan, userPreferences);

      res.json(optimizedData);
    } catch (error: any) {
      console.error("Error creating optimized shopping list:", error);
      res.status(500).json({ message: `Failed to optimize shopping list: ${error.message}` });
    }
  });

  // Intelligent cooking time and difficulty calculation endpoint
  app.post("/api/recipes/calculate-timing", async (req, res) => {
    try {
      const { recipe, constraints } = req.body;

      if (!recipe || !recipe.title || !recipe.ingredients) {
        return res.status(400).json({ message: "Recipe with title and ingredients is required" });
      }

      const { calculateCookingTimeAndDifficulty, getEasyAlternatives } = await import("./cookingTimeCalculator");
      const { validateMealConstraints } = await import("./intelligentPromptBuilder");

      const calculation = calculateCookingTimeAndDifficulty(recipe);
      const alternatives = getEasyAlternatives(recipe);

      let validation = null;
      if (constraints) {
        validation = validateMealConstraints(
          { ...recipe, ...calculation }, 
          constraints
        );
      }

      res.json({
        timing: calculation,
        alternatives,
        validation,
        enhanced_recipe: {
          ...recipe,
          cook_time_minutes: calculation.totalMinutes,
          prep_time_minutes: calculation.prepTime,
          actual_cook_time_minutes: calculation.cookTime,
          difficulty: calculation.difficulty
        }
      });
    } catch (error: any) {
      console.error("Error calculating cooking timing:", error);
      res.status(500).json({ message: `Failed to calculate timing: ${error.message}` });
    }
  });

  // Batch cooking time estimation for meal planning
  app.post("/api/recipes/batch-timing", async (req, res) => {
    try {
      const { recipes } = req.body;

      if (!recipes || !Array.isArray(recipes)) {
        return res.status(400).json({ message: "Array of recipes is required" });
      }

      const { estimateBatchCookingTime } = await import("./cookingTimeCalculator");
      const batchEstimate = estimateBatchCookingTime(recipes);

      res.json(batchEstimate);
    } catch (error: any) {
      console.error("Error calculating batch timing:", error);
      res.status(500).json({ message: `Failed to calculate batch timing: ${error.message}` });
    }
  });

  // Dietary-cultural conflict resolution endpoint
  app.post("/api/recipes/resolve-conflicts", async (req, res) => {
    try {
      const { mealRequest, dietaryRestrictions, culturalBackground } = req.body;

      if (!mealRequest) {
        return res.status(400).json({ message: "Meal request is required" });
      }

      const { resolveDietaryCulturalConflicts, hasQuickConflict, getIngredientSubstitutions } = await import("./dietaryCulturalConflictResolver");

      // Provide defaults for optional parameters
      const restrictions = dietaryRestrictions || [];
      const cultural = culturalBackground || [];

      const resolution = await resolveDietaryCulturalConflicts(
        mealRequest,
        restrictions,
        cultural
      );

      res.json({
        success: true,
        mealRequest,
        resolution,
        quickCheck: hasQuickConflict(mealRequest, restrictions)
      });
    } catch (error: any) {
      console.error("Error resolving dietary conflicts:", error);
      res.status(500).json({ 
        success: false,
        message: `Failed to resolve conflicts: ${error.message}` 
      });
    }
  });

  // Get ingredient substitutions endpoint
  app.post("/api/recipes/ingredient-substitutions", async (req, res) => {
    try {
      const { ingredient, dietaryRestriction } = req.body;

      if (!ingredient || !dietaryRestriction) {
        return res.status(400).json({ message: "Ingredient and dietary restriction are required" });
      }

      const { getIngredientSubstitutions } = await import("./dietaryCulturalConflictResolver");
      const substitutions = getIngredientSubstitutions(ingredient, dietaryRestriction);

      res.json({
        success: true,
        ingredient,
        dietaryRestriction,
        substitutions
      });
    } catch (error: any) {
      console.error("Error getting ingredient substitutions:", error);
      res.status(500).json({ 
        success: false,
        message: `Failed to get substitutions: ${error.message}` 
      });
    }
  });

  // Helper function to get the actual database user ID
  async function getDatabaseUserId(req: any): Promise<string | null> {
    // For JWT auth, just return the user ID directly
    if (req.user?.id) {
      return req.user.id;
    }
    
    return null;
  }

  // Profile routes
  app.get("/api/profile", authenticateToken, async (req: any, res) => {
    try {
      const userId = await getDatabaseUserId(req);
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const profile = await storage.getProfile(userId);
      res.json(profile);
    } catch (error) {
      console.error("Error fetching profile:", error);
      res.status(500).json({ message: "Failed to fetch profile" });
    }
  });

  app.post("/api/profile", authenticateToken, async (req: any, res) => {
    try {
      const userId = await getDatabaseUserId(req);
      if (!userId) {
        console.error('Profile creation failed: User not authenticated');
        return res.status(401).json({ message: "User not authenticated" });
      }

      console.log('Creating profile for user:', userId);
      console.log('Request body:', req.body);

      // Validate required fields
      const { profile_name, primary_goal } = req.body;
      if (!profile_name?.trim()) {
        console.error('Profile creation failed: Missing profile name');
        return res.status(400).json({ message: "Profile name is required" });
      }

      if (!primary_goal) {
        console.error('Profile creation failed: Missing primary goal');
        return res.status(400).json({ message: "Primary goal is required" });
      }

      try {
        const profileData = insertProfileSchema.parse({
          user_id: userId,
          ...req.body
        });

        console.log('Parsed profile data:', profileData);

        const profile = await storage.createProfile(profileData);
        console.log('Created profile:', profile);

        // PROACTIVE CULTURAL DATA CACHING: Auto-cache cultural data after profile creation
        if (profileData.cultural_background && Array.isArray(profileData.cultural_background) && profileData.cultural_background.length > 0) {
          try {
            console.log(`🚀 Auto-caching cultural data for new profile: [${profileData.cultural_background.join(', ')}]`);

            // Import and trigger cultural data caching asynchronously
            import('./cultureCacheManager').then(async ({ getCachedCulturalCuisine }) => {
              try {
                for (const culture of profileData.cultural_background || []) {
                  await getCachedCulturalCuisine(userId, [culture]);
                  console.log(`   ✅ Cached cultural data for: ${culture}`);
                }
                console.log(`🎯 Auto-caching complete for user ${userId}`);
              } catch (cacheError) {
                console.warn('Auto-caching failed:', cacheError);
              }
            });
          } catch (error) {
            console.warn('Failed to trigger auto-caching:', error);
          }
        }

        res.json(profile);
      } catch (parseError) {
        console.error('Profile creation failed: Schema validation error:', parseError);
        if (parseError instanceof Error) {
          return res.status(400).json({ 
            message: "Invalid profile data", 
            details: parseError.message 
          });
        }
        return res.status(400).json({ message: "Invalid profile data format" });
      }
    } catch (error) {
      console.error("Error creating profile:", error);
      const errorMessage = error instanceof Error ? error.message : "Failed to create profile";
      res.status(500).json({ 
        message: "Failed to create profile",
        error: errorMessage 
      });
    }
  });

  app.put("/api/profile", authenticateToken, async (req: any, res) => {
    try {
      const userId = await getDatabaseUserId(req);
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const profile = await storage.updateProfile(userId, req.body);
      if (!profile) {
        return res.status(404).json({ message: "Profile not found" });
      }

      // CACHE INVALIDATION AND REFRESH: Clear old cache and refresh cultural data on profile update
      if (req.body.cultural_background) {
        try {
          console.log(`🔄 Profile cultural background updated for user ${userId}: [${req.body.cultural_background.join(', ')}]`);

          import('./cultureCacheManager').then(async ({ clearUserCache, getCachedCulturalCuisine }) => {
            try {
              // Clear existing cache for this user
              clearUserCache(userId);
              console.log(`   🗑️ Cleared old cultural cache for user ${userId}`);

              // Refresh cache with new cultural background
              if (req.body.cultural_background && req.body.cultural_background.length > 0) {
                for (const culture of req.body.cultural_background) {
                  await getCachedCulturalCuisine(userId, [culture]);
                  console.log(`   ✅ Refreshed cultural data for: ${culture}`);
                }
                console.log(`🎯 Cache refresh complete for user ${userId}`);
              }
            } catch (cacheError) {
              console.warn('Cache refresh failed:', cacheError);
            }
          });
        } catch (error) {
          console.warn('Failed to trigger cache refresh:', error);
        }
      }

      res.json(profile);
    } catch (error) {
      console.error("Error updating profile:", error);
      res.status(500).json({ message: "Failed to update profile" });
    }
  });

  // Weight-based profile routes
  app.get("/api/profile/weight-based", authenticateToken, async (req: any, res) => {
    try {
      const userId = await getDatabaseUserId(req);
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      // Try to get existing profile first
      const existingProfile = await storage.getProfile(userId);
      
      if (existingProfile) {
        console.log('🔍 Processing existing profile for weight extraction:', {
          profile_name: existingProfile.profile_name,
          goals: existingProfile.goals,
          goalsType: typeof existingProfile.goals,
          goalsIsArray: Array.isArray(existingProfile.goals),
          goalsLength: existingProfile.goals?.length
        });

        // Extract stored goal weights - handle both object and array formats
        const storedGoalWeights: any = {
          cost: 0.5,
          health: 0.5,
          cultural: 0.5,
          variety: 0.5,
          time: 0.5
        };

        let parsedWeightsCount = 0;

        if (existingProfile.goals) {
          console.log('📋 Processing goals data:', existingProfile.goals, 'type:', typeof existingProfile.goals);
          
          // Handle object format (e.g., {"cost":0.8,"health":0.5,...})
          if (typeof existingProfile.goals === 'object' && !Array.isArray(existingProfile.goals)) {
            console.log('📋 Processing goals as object format');
            
            Object.entries(existingProfile.goals).forEach(([key, value]) => {
              console.log(`🔍 Processing goal object entry: key="${key}", value="${value}"`);
              
              if (typeof value === 'number' && value >= 0 && value <= 1) {
                storedGoalWeights[key] = value;
                parsedWeightsCount++;
                console.log(`   ✅ Set ${key} = ${value}`);
              } else {
                console.log(`   ❌ Invalid weight value: ${value}`);
              }
            });
          }
          // Handle array format (e.g., ["cost:0.8", "health:0.5", ...])
          else if (Array.isArray(existingProfile.goals)) {
            console.log('📋 Processing goals as array format');
            
            existingProfile.goals.forEach((goal: string, index: number) => {
              console.log(`🔍 Processing goal ${index}:`, goal, typeof goal);
              
              if (typeof goal === 'string' && goal.includes(':')) {
                const [key, value] = goal.split(':');
                console.log(`   Split result: key="${key}", value="${value}"`);
                
                if (key && value) {
                  const weight = parseFloat(value);
                  console.log(`   Parsed weight: ${weight}, isNaN: ${isNaN(weight)}`);
                  
                  if (!isNaN(weight) && weight >= 0 && weight <= 1) {
                    storedGoalWeights[key] = weight;
                    parsedWeightsCount++;
                    console.log(`   ✅ Set ${key} = ${weight}`);
                  } else {
                    console.log(`   ❌ Invalid weight value: ${weight}`);
                  }
                } else {
                  console.log(`   ❌ Missing key or value after split`);
                }
              } else {
                console.log(`   ❌ Goal is not string or doesn't contain ":"`);
              }
            });
          } else {
            console.log('❌ Goals is neither object nor array');
          }
        } else {
          console.log('❌ Goals is null/undefined');
        }

        console.log('📊 Final extracted stored goal weights:', storedGoalWeights);
        console.log(`📊 Successfully parsed ${parsedWeightsCount} weights from ${existingProfile.goals?.length || 0} goals`);
        
        // Convert existing profile to weight-based format
        const weightBasedProfile = {
          profileName: existingProfile.profile_name || 'My Profile',
          familySize: existingProfile.family_size || 2,
          goalWeights: storedGoalWeights,
          dietaryRestrictions: existingProfile.preferences || [],
          culturalBackground: existingProfile.cultural_background || []
        };
        
        res.json(weightBasedProfile);
      } else {
        res.json(null);
      }
    } catch (error) {
      console.error("Error fetching weight-based profile:", error);
      res.status(500).json({ message: "Failed to fetch weight-based profile" });
    }
  });

  app.post("/api/profile/weight-based", authenticateToken, async (req: any, res) => {
    try {
      const userId = await getDatabaseUserId(req);
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const { profileName, familySize, goalWeights, dietaryRestrictions, culturalBackground, questionnaire_answers, questionnaire_selections } = req.body;

      console.log('💾 Creating weight-based profile with data:', {
        profileName,
        familySize,
        goalWeights,
        dietaryRestrictions,
        culturalBackground,
        questionnaire_answers,
        questionnaire_selections
      });

      // Convert goalWeights to goals array format
      const goalsArray = Object.entries(goalWeights).map(([goal, weight]) => `${goal}:${weight}`);
      console.log('💾 Converted goalWeights to goals array for creation:', goalsArray);

      // Create profile using existing schema structure
      const profileData = {
        user_id: userId,
        profile_name: profileName,
        primary_goal: 'Weight-Based Planning',
        family_size: familySize,
        members: [], // Empty for weight-based approach
        profile_type: 'individual' as const,
        preferences: dietaryRestrictions,
        goals: goalsArray,
        cultural_background: culturalBackground
      };

      console.log('💾 Final profileData being created:', profileData);

      const profile = await storage.createProfile(profileData);
      
      console.log('💾 Profile created successfully:', {
        profile_name: profile.profile_name,
        goals: profile.goals,
        savedGoalWeights: goalWeights
      });

      const response = {
        profileName: profile.profile_name,
        familySize: profile.family_size,
        goalWeights,
        dietaryRestrictions: profile.preferences,
        culturalBackground: profile.cultural_background
      };

      console.log('💾 Returning creation response to client:', response);
      res.json(response);
    } catch (error) {
      console.error("Error creating weight-based profile:", error);
      res.status(500).json({ message: "Failed to create weight-based profile" });
    }
  });

  app.put("/api/profile/weight-based", authenticateToken, async (req: any, res) => {
    try {
      const userId = await getDatabaseUserId(req);
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const { profileName, familySize, goalWeights, dietaryRestrictions, culturalBackground, questionnaire_answers, questionnaire_selections } = req.body;

      console.log('💾 Saving weight-based profile with data:', {
        profileName,
        familySize,
        goalWeights,
        dietaryRestrictions,
        culturalBackground,
        questionnaire_answers,
        questionnaire_selections
      });

      // Convert goalWeights to goals array format
      const goalsArray = Object.entries(goalWeights).map(([goal, weight]) => `${goal}:${weight}`);
      console.log('💾 Converted goalWeights to goals array:', goalsArray);

      // Check if profile exists first
      const existingProfile = await storage.getProfile(userId);
      
      let profile;
      if (existingProfile) {
        // Update existing profile
        const profileData = {
          profile_name: profileName || existingProfile.profile_name || 'My Profile',
          primary_goal: 'Weight-Based Planning',
          family_size: familySize || existingProfile.family_size || 2,
          members: existingProfile.members || [],
          profile_type: 'individual' as const,
          preferences: dietaryRestrictions || existingProfile.preferences || [],
          goals: goalsArray,
          cultural_background: culturalBackground || existingProfile.cultural_background || []
        };

        console.log('💾 Final profileData being updated:', profileData);
        profile = await storage.updateProfile(userId, profileData);
      } else {
        // Create new profile
        const profileData = {
          user_id: userId,
          profile_name: profileName || 'My Profile',
          primary_goal: 'Weight-Based Planning',
          family_size: familySize || 2,
          members: [],
          profile_type: 'individual' as const,
          preferences: dietaryRestrictions || [],
          goals: goalsArray,
          cultural_background: culturalBackground || []
        };

        console.log('💾 Final profileData being created:', profileData);
        profile = await storage.createProfile(profileData);
      }

      console.log('💾 Profile saved successfully:', {
        profile_name: profile.profile_name,
        goals: profile.goals,
        savedGoalWeights: goalWeights
      });

      const response = {
        profileName: profile.profile_name,
        familySize: profile.family_size,
        goalWeights,
        dietaryRestrictions: profile.preferences,
        culturalBackground: profile.cultural_background
      };

      console.log('💾 Returning response to client:', response);
      res.json(response);
    } catch (error) {
      console.error("Error updating weight-based profile:", error);
      res.status(500).json({ message: "Failed to update weight-based profile" });
    }
  });

  // NLP Culture Parser route
  app.post("/api/culture-parser", authenticateToken, async (req: any, res) => {
    try {
      const { text } = req.body;

      if (!text || typeof text !== 'string') {
        return res.status(400).json({ message: "Text input is required" });
      }

      // Import the NLP culture parser
      const { nlpCultureParser } = await import('./nlpCultureParser');
      const result = await nlpCultureParser(text);

      res.json(result);
    } catch (error) {
      console.error("Error in culture parser:", error);
      res.status(500).json({ message: "Failed to parse cultural input" });
    }
  });

  // Cultural cuisine data route
  app.get("/api/cultural-cuisine/:cuisine", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      const { cuisine } = req.params;

      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      if (!cuisine) {
        return res.status(400).json({ message: "Cuisine parameter is required" });
      }

      const { getCulturalCuisineData } = await import('./cultureCacheManager');
      const cuisineData = await getCulturalCuisineData(userId, cuisine);

      if (!cuisineData) {
        return res.status(404).json({ message: "Cuisine data not found" });
      }

      res.json(cuisineData);
    } catch (error) {
      console.error("Error fetching cultural cuisine data:", error);
      res.status(500).json({ message: "Failed to fetch cuisine data" });
    }
  });

  // Trigger cultural cuisine caching for user's profile
  app.post("/api/cache-cultural-cuisines", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;

      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      // Get user's cultural background
      const profile = await storage.getProfile(userId);
      if (!profile || !profile.cultural_background) {
        return res.status(404).json({ message: "No cultural preferences found in profile" });
      }

      const culturalBackground = Array.isArray(profile.cultural_background) 
        ? profile.cultural_background 
        : [];

      if (culturalBackground.length === 0) {
        return res.json({ message: "No cultural cuisines to cache", cached: [] });
      }

      const { getCulturalCuisineData } = await import('./cultureCacheManager');
      const cachePromises = culturalBackground.map(cuisine => 
        getCulturalCuisineData(userId, cuisine)
      );

      const results = await Promise.allSettled(cachePromises);
      const cached = culturalBackground.filter((_, index) => 
        results[index].status === 'fulfilled' && results[index].value !== null
      );

      res.json({ 
        message: `Cached data for ${cached.length} cuisines`, 
        cached,
        total: culturalBackground.length 
      });
    } catch (error) {
      console.error("Error caching cultural cuisines:", error);
      res.status(500).json({ message: "Failed to cache cultural cuisine data" });
    }
  });

  // Get cache statistics
  app.get("/api/culture-cache-stats", authenticateToken, async (req: any, res) => {
    try {
      const { getCacheStats } = await import('./cultureCacheManager');
      const stats = getCacheStats();
      res.json(stats);
    } catch (error) {
      console.error("Error getting cache stats:", error);
      res.status(500).json({ message: "Failed to get cache statistics" });
    }
  });

  // Clear all cultural cache data endpoint  
  app.post("/api/clear-cultural-cache", async (req, res) => {
    try {
      const { clearAllCache } = await import('./cultureCacheManager');
      clearAllCache();

      res.json({
        success: true,
        message: "All cultural cache data has been cleared. Fresh research will be performed for all cuisines."
      });
    } catch (error) {
      console.error('🚨 Error clearing cultural cache:', error);
      res.status(500).json({
        error: 'Failed to clear cache',
        message: 'Unable to clear cultural cache data'
      });
    }
  });

  // Save cultural meals to user profile
  app.post("/api/save-cultural-meals", async (req, res) => {
    const { saveCulturalMeals } = await import('./routes/save-cultural-meals');
    return saveCulturalMeals(req, res);
  });

  // Get user's saved cultural meals
  app.get("/api/saved-cultural-meals", async (req, res) => {
    try {
      const userId = 9; // Default user ID for testing
      const { userSavedCulturalMeals } = await import('../shared/schema');
      const { eq } = await import('drizzle-orm');

      // Mock response for saved cultural meals
      const savedMeals: any[] = [];

      res.json({
        success: true,
        saved_meals: savedMeals
      });

    } catch (error) {
      console.error('❌ Error fetching saved cultural meals:', error);
      res.status(500).json({
        error: 'Failed to fetch saved meals',
        message: 'An internal server error occurred'
      });
    }
  });

  // Cultural cuisine research endpoint
  app.post("/api/cultural-cuisine-research", async (req, res) => {
    try {
      const { cuisine } = req.body;

      if (!cuisine || typeof cuisine !== 'string') {
        return res.status(400).json({
          error: 'Missing or invalid cuisine parameter',
          message: 'Please provide a valid cuisine name to research'
        });
      }

      if (cuisine.trim().length === 0) {
        return res.status(400).json({
          error: 'Empty cuisine name',
          message: 'Cuisine name cannot be empty'
        });
      }

      const trimmedCuisine = cuisine.trim();
      console.log(`🔍 Research request for cuisine: ${trimmedCuisine}`);

      // Use the existing Perplexity integration to fetch detailed cuisine data
      // Using a temporary userId (0) since this is for research only - check cache first
      const { getCulturalCuisineData } = await import('./cultureCacheManager');
      const cuisineData = await getCulturalCuisineData(0, trimmedCuisine);

      if (!cuisineData) {
        console.error(`❌ Failed to fetch research data for cuisine: ${trimmedCuisine}`);
        return res.status(404).json({
          error: 'Research failed',
          message: `Unable to find detailed information for ${trimmedCuisine} cuisine. Please try again or check the cuisine name.`
        });
      }

      console.log(`✅ Successfully researched ${trimmedCuisine} cuisine`);

      // Return the detailed cuisine research data
      res.json({
        cuisine: trimmedCuisine,
        culture: (cuisineData as any).culture || trimmedCuisine,
        meals: cuisineData.meals || [],
        summary: cuisineData.summary || {
          common_healthy_ingredients: [],
          common_cooking_techniques: []
        },
        research_timestamp: new Date().toISOString(),
        data_source: 'Perplexity AI'
      });

    } catch (error) {
      console.error('🚨 Error in cultural cuisine research endpoint:', error);

      // Handle different types of errors
      if (error instanceof Error) {
        if (error.message.includes('rate limit') || error.message.includes('Rate limited')) {
          return res.status(429).json({
            error: 'Rate limit exceeded',
            message: 'Too many research requests. Please wait a moment before trying again.',
            retry_after: 60
          });
        }

        if (error.message.includes('API key') || error.message.includes('Authorization')) {
          return res.status(503).json({
            error: 'Service configuration error',
            message: 'Research service is temporarily unavailable. Please try again later.'
          });
        }
      }

      res.status(500).json({
        error: 'Internal server error',
        message: 'An unexpected error occurred while researching the cuisine. Please try again.'
      });
    }
  });

  // Perplexity Search Cache Endpoints
  app.get("/api/perplexity-cache", async (req, res) => {
    try {
      const { perplexityLogger } = await import('./perplexitySearchLogger');
      const searchHistory = await perplexityLogger.getSearchHistory(100);
      res.json(searchHistory);
    } catch (error) {
      console.error('Failed to get Perplexity cache:', error);
      res.status(500).json({ error: 'Failed to load search history' });
    }
  });

  app.delete("/api/perplexity-cache", async (req, res) => {
    try {
      const { perplexityLogger } = await import('./perplexitySearchLogger');
      await perplexityLogger.clearSearchHistory();
      res.json({ success: true, message: 'Search history cleared' });
    } catch (error) {
      console.error('Failed to clear Perplexity cache:', error);
      res.status(500).json({ error: 'Failed to clear search history' });
    }
  });

  app.get("/api/perplexity-cache/stats", async (req, res) => {
    try {
      const { perplexityLogger } = await import('./perplexitySearchLogger');
      const stats = await perplexityLogger.getSearchStats();
      res.json(stats);
    } catch (error) {
      console.error('Failed to get Perplexity cache stats:', error);
      res.status(500).json({ error: 'Failed to load cache statistics' });
    }
  });

  /**
   * Validate and round difficulties to nearest 0.5 within max constraint
   */
  function validateAndRoundDifficulties(mealPlan: any, maxDifficulty: number) {
    Object.keys(mealPlan).forEach(day => {
      const dayMeals = mealPlan[day];
      if (typeof dayMeals === 'object') {
        Object.keys(dayMeals).forEach(mealType => {
          const meal = dayMeals[mealType];
          if (meal && typeof meal.difficulty === 'number') {
            // Round to nearest 0.5 increment
            const roundedDifficulty = Math.round(meal.difficulty * 2) / 2;

            // Ensure it doesn't exceed the maximum
            const finalDifficulty = Math.min(roundedDifficulty, maxDifficulty);

            if (meal.difficulty !== finalDifficulty) {
              console.log(`Adjusted difficulty: ${day} ${mealType} from ${meal.difficulty} to ${finalDifficulty}`);
              meal.difficulty = finalDifficulty;
            }
          }
        });
      }
    });
  }

  // Achievement routes
  app.get("/api/achievements", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      let achievements = await storage.getUserAchievements(userId);
      
      // Initialize achievements if none exist
      if (achievements.length === 0) {
        achievements = await storage.initializeUserAchievements(userId);
      }

      res.json(achievements);
    } catch (error) {
      console.error("Error fetching achievements:", error);
      res.status(500).json({ message: "Failed to fetch achievements" });
    }
  });

  app.post("/api/achievements/trigger", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const { achievementId, progress } = req.body;

      if (!achievementId) {
        return res.status(400).json({ message: "Achievement ID is required" });
      }

      // Get current achievement
      const achievement = await storage.getUserAchievement(userId, achievementId);
      if (!achievement) {
        return res.status(404).json({ message: "Achievement not found" });
      }

      const newProgress = progress || (achievement.progress || 0) + 1;
      const isUnlocked = newProgress >= achievement.max_progress;

      const updatedAchievement = await storage.updateUserAchievement(userId, achievementId, {
        progress: newProgress,
        is_unlocked: isUnlocked,
        unlocked_date: isUnlocked ? new Date() : undefined
      });

      res.json({
        achievement: updatedAchievement,
        isNewlyUnlocked: isUnlocked && !achievement.is_unlocked
      });
    } catch (error) {
      console.error("Error triggering achievement:", error);
      res.status(500).json({ message: "Failed to trigger achievement" });
    }
  });

  app.get("/api/achievements/:achievementId", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const { achievementId } = req.params;
      const achievement = await storage.getUserAchievement(userId, achievementId);

      if (!achievement) {
        return res.status(404).json({ message: "Achievement not found" });
      }

      res.json(achievement);
    } catch (error) {
      console.error("Error fetching achievement:", error);
      res.status(500).json({ message: "Failed to fetch achievement" });
    }
  });

  // Enhanced Cultural Ranking + Llama Meal Plan Generation
  app.post("/api/enhanced-meal-plan", authenticateToken, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "User not authenticated" });
      }

      const { 
        numDays = 3, 
        mealsPerDay = 3, 
        goalWeights,
        profile: userProfile
      } = req.body;

      console.log(`🚀 Enhanced meal plan request: ${numDays} days, ${mealsPerDay} meals/day`);

      // Get user's profile data
      const profile = userProfile || await storage.getProfile(userId);
      if (!profile) {
        return res.status(404).json({ message: "Profile not found" });
      }

      // Import enhanced meal plan generator
      const { enhancedMealPlanGenerator, EnhancedMealPlanGenerator } = await import('./enhancedMealPlanGenerator');
      
      // Build cultural profile from user data
      const culturalProfile = EnhancedMealPlanGenerator.buildUserProfile(profile, goalWeights);
      
      console.log('🎯 Cultural profile:', {
        culturalPrefs: Object.keys(culturalProfile.cultural_preferences),
        weights: culturalProfile.priority_weights,
        restrictions: culturalProfile.dietary_restrictions
      });

      // Generate enhanced meal plan
      const mealPlan = await enhancedMealPlanGenerator.generateMealPlan({
        userId: userId,
        numDays,
        mealsPerDay,
        userProfile: culturalProfile,
        servingSize: profile.family_size || 1
      });

      console.log(`✅ Generated enhanced meal plan in ${mealPlan.generation_metadata.processing_time_ms}ms`);

      res.json(mealPlan);

    } catch (error) {
      console.error("❌ Enhanced meal plan generation failed:", error);
      res.status(500).json({ 
        message: "Failed to generate enhanced meal plan",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Simple test endpoint to verify API is working
  app.get("/api/test-simple", (req, res) => {
    res.json({ message: "API is working", timestamp: new Date().toISOString() });
  });



  // Intelligent Meal Base Selection Endpoint
  app.post("/api/intelligent-meal-selection", async (req, res) => {
    try {
      console.log('🤖 Intelligent meal selection endpoint called');
      const { userId = 1, userProfile, selectedMeal, totalMeals = 9 } = req.body;

      if (!userProfile) {
        return res.status(400).json({ error: 'User profile is required' });
      }

      // Import the intelligent meal base selector
      const { intelligentMealBaseSelector } = await import('./intelligentMealBaseSelector.js');

      if (selectedMeal) {
        // User selected a specific base meal - generate plan around it
        console.log(`🎯 Generating meal plan around selected base: ${selectedMeal.meal.name}`);
        
        // Create base meal selection object
        const baseMealSelection = {
          baseMeal: selectedMeal.meal,
          similarity_score: selectedMeal.total_score,
          usage_rationale: selectedMeal.ranking_explanation || 'Selected by user as preferred base meal',
          weight_alignment: selectedMeal.component_scores
        };

        const mealPlan = await intelligentMealBaseSelector.generateMealPlanWithBase(
          userId,
          userProfile,
          baseMealSelection,
          totalMeals
        );

        console.log(`✅ Generated meal plan with ${mealPlan.complementaryMeals.length + mealPlan.variety_boost_meals.length + 1} meals`);

        res.json({
          success: true,
          mealPlan,
          processingTime: Date.now()
        });

      } else {
        // Auto-select optimal base meal using questionnaire weights
        console.log('🔍 Auto-selecting optimal base meal from user preferences');
        
        const cultures = Object.keys(userProfile.cultural_preferences);
        const baseMealSelection = await intelligentMealBaseSelector.findOptimalBaseMeal(
          userId,
          userProfile,
          cultures
        );

        if (!baseMealSelection) {
          return res.status(404).json({ 
            error: 'No suitable base meal found for your preferences',
            suggestion: 'Try adjusting your cultural preferences or dietary restrictions'
          });
        }

        const mealPlan = await intelligentMealBaseSelector.generateMealPlanWithBase(
          userId,
          userProfile,
          baseMealSelection,
          totalMeals
        );

        console.log(`✅ Auto-generated meal plan with optimal base: ${baseMealSelection.baseMeal.name}`);

        res.json({
          success: true,
          mealPlan,
          autoSelectedBase: true,
          processingTime: Date.now()
        });
      }

    } catch (error) {
      console.error('❌ Error in intelligent meal selection:', error);
      res.status(500).json({ 
        error: 'Internal server error during intelligent meal selection',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}